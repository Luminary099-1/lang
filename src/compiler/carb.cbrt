#include "./syntaxTree/base.hpp"
#include "./syntaxTree/common.hpp"
#include "./syntaxTree/globals.hpp"

#include <cstdlib>
#include <string>
#include <string_view>
#include <utility>

%no_externc
%prefix carb_

%header%
#include "./syntaxTree/base.hpp"
%%



%scanner%
%common_class TokenInfo

$:
{
	$._row = $line;
	$._endRow = $endline;
	$._col = $column;
	$._endCol = $endcolumn;
	$._off = $offset;
	$._endOff = $endoffset;
}

: [\ \t\n]+;	/* Skips whitespace. */
ASSIGN: =;
SEMICOL: \;;
COMMA: \,;
PLUS: \+;
MINUS: \-;
ASTERISK: \*;
SLASH: /;
PERCENT: %;
INC: \+\+;
DEC: \-\-;
AND: &;
OR: \|;
XOR: \^;
COMP: ~;
SHR: >>;
SHL: <<;
LAND: &&;
LOR: \|\|;
DENY: !;
EQ: ==;
NE: !=;
GT: >;
LT: <;
GE: >=;
LE: <=;
LPAREN: \(;
RPAREN: \);
LCURLY: \{;
RCURLY: \};
LBRACK: <;
RBRACK: >;
LARROW: <\-;
RARROW: \->;
IF: if;
ELSE: else;
MATCH: match;
FOR: for;
LOOP: loop;
WHILE: while;
BOOLEAN: true|false { $$ = std::string($text); }
BREAK: break;
RETURN: return;
INTEGER: [0-9]+ { $$ = std::string($text); }
LEVELS: [0-9]+ { $$ = std::string($text); }
ID: [a-zA-Z_][a-zA-Z0-9_]* { $$ = std::string($text); }
STRING: \".*\" { $$ = std::string($text); }

%token ASSIGN SEMICOL COMMA PLUS MINUS ASTERISK SLASH PERCENT INC DEC AND OR XOR COMP SHR SHL LAND
%token LOR DENY EQ NE GT LT GE LE LPAREN RPAREN LCURLY RCURLY LBRACK RBRACK LARROW RARROW INTEGER
%token LEVELS ID STRING IF ELSE MATCH FOR LOOP WHILE BOOLEAN BREAK RETURN

%class BOOLEAN INTEGER LEVELS ID STRING: std::string
/* Not sure what else to put here for now. */
%token_type int


%nt globals global function_def param_list param_list_tail param statement compound_stmt statements
%nt open_stmt closed_stmt general_stmt var_def_stmt expression assignment_expr for_expr loop_expr
%nt while_expr break_stmt return_stmt expr_maybe primary_expr arg_list arg_list_tail pre_expr
%nt multiplicative_expr additive_expr shift_expr relative_expr absolute_expr bit_and_expr
%nt bit_xor_expr bit_or_expr logic_and_expr logic_or_expr literal


%grammar%
%params std::vector<SyntaxTreeNode*>& output

globals: global globals
	{}
globals: ;

global: function_def
	{}
global: var_def_stmt
	{}

function_def: ID LPAREN param_list RPAREN RARROW ID LCURLY statements RCURLY
	{}

param_list: param param_list_tail
	{}
param_list:
	{}

param_list_tail: COMMA param param_list_tail
	{}
param_list_tail:
	{}

param: ID ID
	{}

statement: open_stmt
	{}
statement: closed_stmt
	{}

open_stmt: IF LPAREN expression RPAREN statement
	{}
open_stmt: IF LPAREN expression RPAREN closed_stmt ELSE open_stmt
	{}

closed_stmt: IF LPAREN expression RPAREN closed_stmt ELSE closed_stmt
	{}
closed_stmt: general_stmt
	{}

general_stmt: compound_stmt
	{}
general_stmt: var_def_stmt
	{}
general_stmt: expression SEMICOL
	{}
general_stmt: break_stmt
	{}
general_stmt: return_stmt
	{}

compound_stmt: LCURLY statements RCURLY
	{}
compound_stmt: LCURLY statements LARROW expression RCURLY
	{}

statements: statement statements
	{}
statements:
	{}

var_def_stmt: ID ID ASSIGN expression SEMICOL
	{}

expression: assignment_expr
	{}
expression: for_expr
	{}
expression: loop_expr
	{}
expression: while_expr
	{}
expression: logic_or_expr
	{}

assignment_expr: ID ASSIGN expression
	{}

for_expr: FOR LPAREN expr_maybe SEMICOL expr_maybe SEMICOL expr_maybe RPAREN statement
	{}

loop_expr: LOOP statement
	{}

while_expr: WHILE LPAREN expression RPAREN statement
	{}

break_stmt: BREAK expr_maybe SEMICOL
	{}
break_stmt: BREAK LBRACK INTEGER RBRACK expr_maybe SEMICOL
	{}

return_stmt: RETURN expr_maybe SEMICOL
	{}

expr_maybe: expression
	{}
expr_maybe:
	{}


primary_expr: LPAREN expression RPAREN
	{}
primary_expr: ID LPAREN arg_list RPAREN
	{}
primary_expr: literal
	{}

arg_list: expression arg_list_tail
	{}
arg_list:
	{}

arg_list_tail: COMMA expression arg_list_tail
	{}
arg_list_tail:
	{}

pre_expr: primary_expr
	{}
pre_expr: PLUS primary_expr
	{}
pre_expr: MINUS primary_expr
	{}
pre_expr: INC primary_expr
	{}
pre_expr: DEC primary_expr
	{}
pre_expr: DENY primary_expr
	{}
pre_expr: COMP primary_expr
	{}

multiplicative_expr: pre_expr
	{}
multiplicative_expr: multiplicative_expr ASTERISK pre_expr
	{}
multiplicative_expr: multiplicative_expr SLASH pre_expr
	{}
multiplicative_expr: multiplicative_expr PERCENT pre_expr
	{}

additive_expr: multiplicative_expr
	{}
additive_expr: additive_expr PLUS multiplicative_expr
	{}
additive_expr: additive_expr MINUS multiplicative_expr
	{}

shift_expr: additive_expr
	{}
shift_expr: shift_expr SHL additive_expr
	{}
shift_expr: shift_expr SHR additive_expr
	{}

relative_expr: shift_expr
	{}
relative_expr: relative_expr LT shift_expr
	{}
relative_expr: relative_expr LE shift_expr
	{}
relative_expr: relative_expr GT shift_expr
	{}
relative_expr: relative_expr GE shift_expr
	{}

absolute_expr: relative_expr
	{}
absolute_expr: absolute_expr EQ relative_expr
	{}
absolute_expr: absolute_expr NE relative_expr
	{}

bit_and_expr: absolute_expr
	{}
bit_and_expr: bit_and_expr AND absolute_expr
	{}

bit_xor_expr: bit_and_expr
	{}
bit_xor_expr: bit_xor_expr XOR bit_and_expr
	{}

bit_or_expr: bit_xor_expr
	{}
bit_or_expr: bit_or_expr OR bit_xor_expr
	{}

logic_and_expr: bit_or_expr
	{}
logic_and_expr: logic_and_expr LAND bit_or_expr
	{}

logic_or_expr: logic_and_expr
	{}
logic_or_expr: logic_or_expr LOR logic_and_expr
	{}


literal: ID
	{}
literal: INTEGER
	{}
literal: BOOLEAN
	{}
literal: STRING
	{}
