/* Imports will go here */



%scanner%
%prefix carb_

: [\ \t\n]+;	/* Skips whitespace. */
ASSIGN: =;
SEMICOL: \;;
COMMA: ,;
PLUS: \+;
MINUS: \-;
ASTERISK: \*;
SLASH: /;
PERCENT: %;
INC: \+\+;
DEC: \-\-;
AND: &;
OR: |;
XOR: ^;
COMP: ~;
SHR: >>;
SHL: <<;
LAND: &&;
LOR: ||;
DENY: !;
EQUAL: ==;
NEQUAL: !=;
GREATER: >;
LESSER: <;
GREATEQ: >=;
LESSEQ: <=;
LPAREN: \(;;
RPAREN: \);
LCURLY: \{;
RCURLY: \};
DECIMAL: [0-9]+;
ID: [a-zA-Z_][a-zA-Z0-9_]+;
IF: if;
ELSE: else;
MATCH: match;
FOR: for;
LOOP: loop;
WHILE: while;
TRUE: true;
FALSE: false;
BREAK: break;

%token ASSIGN SEMICOL COMMA PLUS MINUS ASTERISK SLASH PERCENT INC DEC AND OR XOR COMP SHR SHL LAND
%token LOR DENY EQUAL NEQUAL GREATER LESSER GREATEQ LESSEQ LPAREN RPAREN LCURLY RCURLY DECIMAL ID IF
%token ELSE MATCH FOR LOOP WHILE TRUE FALSE BREAK

%nt globals global type_expr function_def param_list param_list_tail param statement compound_stmt
%nt statements var_def_stmt expression expression_stmt assignment_expr if_expr for_expr loop_expr
%nt while_expr break_stmt expr_maybe enclosed_expr pre_expr multiplicative_expr additive_expr
%nt shift_expr relative_expr absolute_expr bit_and_expr bit_xor_expr bit_or_expr logic_and_expr
%nt logic_or_expr literal boolean



%grammar%

globals: global globals;
globals: ;

global: function_def;
global: var_def_stmt;

type_expr: ID;

function_def: type_expr ID LPAREN param_list RPAREN compound_stmt;

param_list: param param_list_tail;
param_list: ;

param_list_tail: COMMA param param_list_tail;
param_list_tail: ;

param: type_expr ID;

statement: compound_stmt;
statement: var_def_stmt;
statement: expression;
statement: expression_stmt;
statement: break_stmt;

compound_stmt: LCURLY statements RCURLY;

statements: statement statements;
statements: ;

var_def_stmt: type_expr ID ASSIGN expression SEMICOL;

expression: assignment_expr;
expression: if_expr;
expression: for_expr;
expression: loop_expr;
expression: while_expr:
expression: logic_or_expr;

expression_stmt: expression SEMICOL;

assignment_expr: ID ASSIGN expression;

if_expr: IF LPAREN expression RPAREN statement;

for_expr: FOR LPAREN expr_maybe SEMICOL expr_maybe SEMICOL expr_maybe RPAREN statement;

loop_expr: LOOP statement;

while_expr: WHILE LPAREN expression RPAREN statement;

break_stmt: BREAK expr_maybe SEMICOL;
break_stmt: BREAK LPAREN DECIMAL RPAREN expr_maybe SEMICOL;

expr_maybe: expression;
expr_maybe: ;


/* TODO: Replace expression parsing with the Shunting Yard algorithm. */
enclosed_expr: LPAREN expression RPAREN;
enclosed_expr: ID LPAREN argument_list RPAREN;
enclosed_expr: expression INC;
enclosed_expr: expression DEC;
enclosed_expr: literal;

pre_expr: PLUS enclosed_expr;
pre_expr: MINUS enclosed_expr;
pre_expr: INC enclosed_expr;
pre_expr: DEC enclosed_expr;
pre_expr: DENY enclosed_expr;
pre_expr: COMP enclosed_expr;

multiplicative_expr: multiplicative_expr ASTERISK pre_expr;
multiplicative_expr: multiplicative_expr SLASH pre_expr;
multiplicative_expr: multiplicative_expr PERCENT pre_expr;

additive_expr: additive_expr PLUS multiplicative_expr;
additive_expr: additive_expr MINUS multiplicative_expr;

shift_expr: shift_expr SHL additive_expr;
shift_expr: shift_expr SHR additive_expr;

relative_expr: relative_expr LESSER shift_expr;
relative_expr: relative_expr LESSEQ shift_expr;
relative_expr: relative_expr GREATER shift_expr;
relative_expr: relative_expr GREATEQ shift_expr;

absolute_expr: absolute_expr EQUAL relative_expr;
absolute_expr: absolute_expr NEQUAL relative_expr;

bit_and_expr: bit_and_expr AND absolute_expr;

bit_xor_expr: bit_xor_expr XOR bit_and_expr;

bit_or_expr: bit_or_expr OR bit_xor_expr;

logic_and_expr: logic_and_expr LAND bit_or_expr;

logic_or_expr: logic_or_expr LOR logic_and_expr;


literal: ID;
literal: DECIMAL;
literal: boolean;

boolean: TRUE;
boolean: FALSE;
