#include "./syntaxTree/base.hpp"
#include "./syntaxTree/function.hpp"
#include "./syntaxTree/statements.hpp"
#include "./syntaxTree/expressions.hpp"
#include "./syntaxTree/constructs.hpp"
#include "./syntaxTree/literals.hpp"

#include <cstdlib>
#include <string>
#include <utility>


/* --------- START OF GENERATED CODE ------------ */
#if defined(__clang__)
#elif defined(__GNUC__) && defined(__cplusplus)
/* don't warn on realloc, memcpy, memset on C++ classes */
#pragma GCC diagnostic ignored "-Wclass-memaccess"
#endif
#include <stdlib.h> /* realloc(), free(), NULL, size_t */
#include <string.h> /* memcpy() */
#include <stddef.h> /* size_t */
#include <stdint.h> /* SIZE_MAX */
struct carb_sym_data {
  #ifdef __cplusplus
  // clear destructor in case C++ symbol types have non-trivial destructors
  // (we invoke their destructors explicitly)
  ~carb_sym_data() = delete;
  #endif
  int state_;
  union {
    int uv0_;
    std::string uv1_;
    int uv2_;
    Unit uv3_;
    SyntaxNode* uv4_;
    TypeNode uv5_;
    FunctionNode* uv6_;
    FunctionNode::ParamList uv7_;
    FunctionNode::ParamList uv8_;
    FunctionNode::Param uv9_;
    StmtNode* uv10_;
    CompoundStmtNode* uv11_;
    CompoundStmtNode::StmtList uv12_;
    VarDefStmtNode* uv13_;
    ExprNode* uv14_;
    ExprStmtNode* uv15_;
    AssignExprNode* uv16_;
    IfExprNode* uv17_;
    ForExprNode* uv18_;
    LoopExprNode* uv19_;
    WhileExprNode* uv20_;
    BreakStmtNode* uv21_;
    Expression* uv22_;
    ExprNode* uv23_;
    InvokeNode::ArgList uv24_;
    InvokeNode::ArgList uv25_;
    PreExprNode* uv26_;
    BinaryExprNode* uv27_;
    BinaryExprNode* uv28_;
    BinaryExprNode* uv29_;
    BinaryExprNode* uv30_;
    BinaryExprNode* uv31_;
    BinaryExprNode* uv32_;
    BinaryExprNode* uv33_;
    BinaryExprNode* uv34_;
    BinaryExprNode* uv35_;
    BinaryExprNode* uv36_;
    LiteralNode* uv37_;
    bool uv38_;
  } v_;
};
static const int carb_scan_table_grouped_rex_[] = {
  /*
   00  01  02  03  04  05  06  07  08  09  0A  0B  0C  0D  0E  0F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D */
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  3,  3,  0,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 20, 21, 20, 22, 23, 20, 24, 20, 25, 26, 20, 20, 20, 20, 27, 20, 28, 29, 30, 31,  1,  2,  1,  1,
    0,  0,  3,  3,  0,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 20, 21, 20, 22, 23, 20, 24, 20, 25, 26, 20, 20, 20, 20, 27, 20, 28, 29, 30, 31,  2,  2,  2,  2,
    0,  0,  3,  3,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  3,  3,  3,  3,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 32,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  4,  4,  4,  4,
    0, 33, 33,  0,  0, 33, 34, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,  5,  5,  5,  5,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  6,  6,  6,  6,
    0,  0,  0,  0,  0,  0,  0,  0, 35,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  7,  7,  7,  7,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  8,  8,  8,  8,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  9,  9,  9,  9,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 10, 10, 10, 10,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 36,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 11, 11, 11, 11,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 12, 12, 12, 12,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 37,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 13, 13, 13, 13,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 14, 14, 14, 14,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 15,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 15, 15, 15, 15,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 16, 16, 16, 16,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 38, 39,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 17, 17, 17, 17,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 40,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 18, 18, 18, 18,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 41, 42,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 19, 19, 19, 19,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 43,  0,  0,  0,  0, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,  0,  0,  0, 20, 20, 20, 20,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 43,  0,  0,  0,  0, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 44, 43, 43, 43, 43,  0,  0,  0, 21, 21, 21, 21,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 43,  0,  0,  0,  0, 43, 43, 43, 43, 43, 43, 43, 43, 43, 45, 43, 43, 43, 43, 43, 43, 43, 43,  0,  0,  0, 22, 22, 22, 22,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 43,  0,  0,  0,  0, 43, 46, 43, 43, 43, 43, 43, 43, 43, 43, 43, 47, 43, 43, 43, 43, 43, 43,  0,  0,  0, 23, 23, 23, 23,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 43,  0,  0,  0,  0, 43, 43, 43, 43, 43, 48, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,  0,  0,  0, 24, 24, 24, 24,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 43,  0,  0,  0,  0, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 49, 43, 43, 43, 43, 43, 43,  0,  0,  0, 25, 25, 25, 25,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 43,  0,  0,  0,  0, 43, 50, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,  0,  0,  0, 26, 26, 26, 26,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 43,  0,  0,  0,  0, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 51, 43, 43, 43, 43,  0,  0,  0, 27, 27, 27, 27,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 43,  0,  0,  0,  0, 43, 43, 43, 43, 43, 43, 52, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,  0,  0,  0, 28, 28, 28, 28,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 29, 29, 29, 29,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 30, 30, 30, 30,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 31, 31, 31, 31,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 32, 32, 32, 32,
    0, 33, 33,  0,  0, 33, 34, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
    0, 33, 33,  0,  0, 33, 34, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 34, 34, 34, 34,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 35, 35, 35, 35,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 36, 36, 36, 36,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 37, 37, 37, 37,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 38, 38, 38, 38,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 39, 39, 39, 39,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 40, 40, 40, 40,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 41, 41, 41, 41,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 42, 42, 42, 42,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 43,  0,  0,  0,  0, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,  0,  0,  0, 43, 43, 43, 43,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 43,  0,  0,  0,  0, 43, 43, 43, 43, 53, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,  0,  0,  0, 44, 44, 44, 44,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 43,  0,  0,  0,  0, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 54, 43, 43, 43,  0,  0,  0, 45, 45, 45, 45,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 43,  0,  0,  0,  0, 43, 43, 43, 43, 43, 43, 43, 43, 43, 55, 43, 43, 43, 43, 43, 43, 43, 43,  0,  0,  0, 46, 46, 46, 46,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 43,  0,  0,  0,  0, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 56, 43, 43, 43, 43,  0,  0,  0, 47, 47, 47, 47,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 43,  0,  0,  0,  0, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,  0,  0,  0, 48, 48, 48, 48,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 43,  0,  0,  0,  0, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 57, 43, 43, 43, 43, 43, 43,  0,  0,  0, 49, 49, 49, 49,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 43,  0,  0,  0,  0, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 58, 43, 43,  0,  0,  0, 50, 50, 50, 50,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 43,  0,  0,  0,  0, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 59, 43,  0,  0,  0, 51, 51, 51, 51,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 43,  0,  0,  0,  0, 43, 43, 43, 43, 43, 43, 43, 60, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,  0,  0,  0, 52, 52, 52, 52,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 43,  0,  0,  0,  0, 43, 61, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,  0,  0,  0, 53, 53, 53, 53,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 43,  0,  0,  0,  0, 43, 43, 43, 43, 62, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,  0,  0,  0, 54, 54, 54, 54,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 43,  0,  0,  0,  0, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 63, 43, 43, 43,  0,  0,  0, 55, 55, 55, 55,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 43,  0,  0,  0,  0, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,  0,  0,  0, 56, 56, 56, 56,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 43,  0,  0,  0,  0, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 64, 43, 43, 43, 43, 43,  0,  0,  0, 57, 57, 57, 57,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 43,  0,  0,  0,  0, 43, 43, 43, 65, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,  0,  0,  0, 58, 58, 58, 58,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 43,  0,  0,  0,  0, 43, 43, 43, 43, 66, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,  0,  0,  0, 59, 59, 59, 59,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 43,  0,  0,  0,  0, 43, 43, 43, 43, 43, 43, 43, 43, 43, 67, 43, 43, 43, 43, 43, 43, 43, 43,  0,  0,  0, 60, 60, 60, 60,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 43,  0,  0,  0,  0, 43, 43, 43, 43, 43, 43, 43, 43, 68, 43, 43, 43, 43, 43, 43, 43, 43, 43,  0,  0,  0, 61, 61, 61, 61,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 43,  0,  0,  0,  0, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,  0,  0,  0, 62, 62, 62, 62,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 43,  0,  0,  0,  0, 43, 43, 43, 43, 69, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,  0,  0,  0, 63, 63, 63, 63,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 43,  0,  0,  0,  0, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,  0,  0,  0, 64, 64, 64, 64,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 43,  0,  0,  0,  0, 43, 43, 43, 43, 43, 43, 70, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,  0,  0,  0, 65, 65, 65, 65,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 43,  0,  0,  0,  0, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,  0,  0,  0, 66, 66, 66, 66,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 43,  0,  0,  0,  0, 43, 43, 43, 43, 71, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,  0,  0,  0, 67, 67, 67, 67,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 43,  0,  0,  0,  0, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,  0,  0,  0, 68, 68, 68, 68,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 43,  0,  0,  0,  0, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,  0,  0,  0, 69, 69, 69, 69,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 43,  0,  0,  0,  0, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,  0,  0,  0, 70, 70, 70, 70,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 43,  0,  0,  0,  0, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,  0,  0,  0, 71, 71, 71, 71
};
static const size_t carb_num_scan_table_grouped_columns_ = 46;
static const int carb_utf8_decoder_[] = {
  /*
   00  01  02  03  04  05  06  07  08  09  0A  0B  0C  0D  0E  0F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32  33  34  35  36  37  38  39  3A  3B  3C  3D  3E  3F  40  41  42  43  44  45  46  47  48  49  4A  4B  4C  4D  4E  4F  50  51  52  53  54  55  56  57  58  59  5A  5B  5C  5D  5E  5F  60  61  62  63  64  65  66  67  68  69  6A  6B  6C  6D  6E  6F  70  71  72  73  74  75  76  77  78  79  7A  7B  7C  7D  7E  7F  80  81  82  83  84  85  86  87  88  89  8A  8B  8C  8D  8E  8F  90  91  92  93  94  95  96  97  98  99  9A  9B  9C  9D  9E  9F  A0  A1  A2  A3  A4  A5  A6  A7  A8  A9  AA  AB  AC  AD  AE  AF  B0  B1  B2  B3  B4  B5  B6  B7  B8  B9  BA  BB  BC  BD  BE  BF  C0  C1  C2  C3  C4  C5  C6  C7  C8  C9  CA  CB  CC  CD  CE  CF  D0  D1  D2  D3  D4  D5  D6  D7  D8  D9  DA  DB  DC  DD  DE  DF  E0  E1  E2  E3  E4  E5  E6  E7  E8  E9  EA  EB  EC  ED  EE  EF  F0  F1  F2  F3  F4  F5  F6  F7  F8  F9  FA  FB  FC  FD  FE  FF */
    1,  1,  1,  1,  1,  1,  1,  1,  1,  2,  3,  1,  1,  4,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  2,  5,  6,  1,  1,  7,  8,  1,  9, 10, 11, 12, 13, 14,  1, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,  1, 17, 18, 19, 20,  1,  1, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,  1,  1,  1,  1, 21,  1, 22, 23, 24, 21, 25, 26, 21, 27, 28, 21, 29, 30, 31, 21, 32, 33, 21, 34, 35, 36, 37, 21, 38, 21, 21, 21, 39,  1, 40, 41,  1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -4, -5, -6, -7, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -8, -9,-10,-11,-11,-11,-12, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  1,  1,  1,  1,  1,  4,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,-13,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14,-14, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,-15,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-17, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,-18,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-19,-20, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  4,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,-21,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-23, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
};
static const size_t carb_scan_actions_rex[] = { 0, 13, 13, 1, 20, 0, 9, 12, 27, 28, 7, 5, 4, 6, 8, 31, 3, 24, 2, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 29, 30, 15, 22, 0, 33, 18, 10, 11, 17, 26, 21, 25, 16, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32 };
static const int carb_minimum_sym = 3;
static const size_t carb_num_columns = 80;
static const int carb_parse_table[] = {
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,154,  0,  0,  0, 0,  0,  0,  0,  0,  0,  0, 0, -3, 1, 3,153, 4, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 0,  0,  0,  0,  0,  0,  0, 0, -1, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 0,  0,  0,  0,  0,  0,  0, 0, -2, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,154,  0,  0,  0, 0,  0,  0,  0,  0,  0,  0, 0, -3, 2, 3,153, 4, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, -4,  0,  0,  0, 0,  0,  0,  0,  0,  0,  0, 0, -4, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, -5,  0,  0,  0, 0,  0,  0,  0,  0,  0,  0, 0, -5, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, -7,  0,  0,  0, 0,  0,  0,  0,  0,  0,  0, 0, -7, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 60,  0,  0,  0,  0,  0,  0, 0,  0,  0,  0,  0,  0,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  7,  0,  0,  0,  0,  0,  0,  0, 0,  0,  0,  0,  0,  0,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, -8,  0,  0,  0,  0,  0,  0,  0, 0,  0,  0,  0,  0,  0,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,-10,  0,  0,  0,  0,  0,  0,  0, 0,  0,  0,  0,  0,  0,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0, 12,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,-11,  0,  0,  0,  0,  0,  0,  0, 0,  0,  0,  0,  0,  0,  0, 0,  0, 0, 0,  0, 0, 0,10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,154,  0,  0,  0, 0,  0,  0,  0,  0,  0,  0, 0,  0, 0, 0, 15, 0, 0, 0,11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0, 12,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,-11,  0,  0,  0,  0,  0,  0,  0, 0,  0,  0,  0,  0,  0,  0, 0,  0, 0, 0,  0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0,-12,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,-12,  0,  0,  0,  0,  0,  0,  0, 0,  0,  0,  0,  0,  0,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 14,  0,  0,  0, 0,  0,  0,  0,  0,  0,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, -9,  0,  0,  0,154,  0,  0,  0, 0,  0,  0,  0,  0,  0,  0, 0,  0, 0, 0, 15, 0, 8, 0,13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,-21,-21,-21,-21,  0,  0,  0,-21,-21,  0,  0,  0,-21,  0,  0,  0,  0,-21,  0,  0,  0,  0,  0,  0,-21,-21,-21,-21,-21,-21,-21,-21,-21, 0,-21,-21,-21,-21,-21,-21, 0,-21, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0, 17,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 0,  0,  0,  0,  0,  0,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,-52,-52,-52,-52,-52,-52,-52,-52,-52,-52,-52,-52,-52,-52,-52,-52,-52,-52,-52,-52,-52,-52,-52,-52,-52,-52,-52,-52,-52,-52,-52,-52,-52, 0,-52,-52,-52,-52,-52,-52, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40, 0,-40,-40,-40,-40,-40,-40, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 20,  0,  0,  0,  0,  0,  0,  0, 0,  0,  0,  0,  0,  0,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,-42,  0,  0,  0,  0,  0,  0,  0, 0,  0,  0,  0,  0,  0,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,-44,  0,  0,  0,  0,  0,  0,  0, 0,  0,  0,  0,  0,  0,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0, 25,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,-45,  0,  0,  0,  0,  0,  0,  0, 0,  0,  0,  0,  0,  0,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,23,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0,  0,132,134,  0,  0,  0,136,138,  0,  0,  0,143,  0,  0,  0,  0,140,  0,  0,  0,  0,  0,  0,144,  0,  0,  0,146, 76,148, 78,  0, 0, 80, 83, 85,149,150,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0,24, 0,67,68,69,70,71, 0, 0,130, 0, 0,129,128,121,116,111,102,97,94,91,88,74,145,147, 0,
    0,  0, 25,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,-45,  0,  0,  0,  0,  0,  0,  0, 0,  0,  0,  0,  0,  0,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,22,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,-34,-34,-34,-34,  0,  0,  0,-34,-34,  0,  0,  0,-34,  0,  0,  0,  0,-34,  0,  0,  0,  0,  0,  0,-34,-34,-34,-34,-34,-34,-34,-34,-34, 0,-34,-34,-34,-34,-34,-34, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0,  0,132,134,  0,  0,  0,136,138,  0,  0,  0,143,  0,  0,  0,  0,140,  0,  0,  0,  0,  0,  0,144,  0, 60,  0,146, 63,148, 78,  0, 0, 80, 83, 85,149,150, 82, 0,  0, 0, 0, 62, 0, 0, 0, 0,27,54, 0,55,57,58,67,68,69,70,71,59, 0,130, 0, 0,129,128,121,116,111,102,97,94,91,88,74,145,147, 0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 28,  0,  0,  0,  0,  0,  0,  0, 0,  0,  0,  0,  0,  0,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,-33,-33,-33,-33,  0,  0,  0,-33,-33,  0,  0,  0,-33,  0,  0,  0,  0,-33,  0,  0,  0,  0,  0,  0,-33,-33,-33,-33,-33,-33,-33,-33,  0, 0,-33,-33,-33,-33,-33,-33, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,-35,-35,-35,-35,  0,  0,  0,-35,-35,  0,  0,  0,-35,  0,  0,  0,  0,-35,  0,  0,  0,  0,  0,  0,-35,-35,-35,-35,-35,-35,-35,-35,-35, 0,-35,-35,-35,-35,-35,-35, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0, 31,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 0,  0,  0,  0,  0,  0,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,-36,-36,-36,-36,  0,  0,  0,-36,-36,  0,  0,  0,-36,  0,  0,  0,  0,-36,  0,  0,  0,  0,  0,  0,-36,-36,-36,-36,-36,-36,-36,-36,-36, 0,-36,-36,-36,-36,-36,-36, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0, 33,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 0,  0,  0,  0,  0,  0,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,-38,  0,132,134,  0,  0,  0,136,138,  0,  0,  0,143,  0,  0,  0,  0,140,  0,  0,  0,  0,  0,  0,144,  0,  0,  0,146, 76,148, 78,  0, 0, 80, 83, 85,149,150,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0,46, 0,67,68,69,70,71, 0,34,130, 0, 0,129,128,121,116,111,102,97,94,91,88,74,145,147, 0,
    0,  0,  0,-82,-82,-82,-82,-82,  0,  0,-82,-82,-82,  0,-82,-82,-82,-82,  0,-82,-82,-82,-82,-82,-82,  0, 35,  0,  0,  0,  0,  0,  0,  0, 0,  0,  0,  0,  0,  0,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,-39,-39,-39,-39,-39,-39,-39,-39,-39,-39,-39,-39,-39,-39,-39,-39,-39,-39,-39,-39,-39,-39,-39,-39,-39,-39,-39,-39,-39,-39,-39,-39,-39, 0,-39,-39,-39,-39,-39,-39, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 37,  0,  0,  0,  0,  0,  0,  0, 0,  0,  0,  0,  0,  0,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,-32,-32,-32,-32,  0,  0,  0,-32,-32,  0,  0,  0,-32,  0,  0,  0,  0,-32,  0,  0,  0,  0,  0,  0,-32,-32,-32,-32,-32,-32,-32,-32,  0, 0,-32,-32,-32,-32,-32,-32, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0,  0,132,134,  0,  0,  0,136,138,  0,  0,  0,143,  0,  0,  0,  0,140,  0,  0,  0,  0,  0,  0,144,  0, 60,  0,146, 63,148, 78,  0, 0, 80, 83, 85,149,150, 82, 0,  0, 0, 0, 62, 0, 0, 0, 0,39,54, 0,55,57,58,67,68,69,70,71,59, 0,130, 0, 0,129,128,121,116,111,102,97,94,91,88,74,145,147, 0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 40,  0,  0,  0,  0,  0,  0,  0, 0,  0,  0,  0,  0,  0,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0,  0,132,134,  0,  0,  0,136,138,  0,  0,  0,143,  0,  0,  0,  0,140,  0,  0,  0,  0,  0,  0,144,-38,  0,  0,146, 76,148, 78,  0, 0, 80, 83, 85,149,150,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0,46, 0,67,68,69,70,71, 0,41,130, 0, 0,129,128,121,116,111,102,97,94,91,88,74,145,147, 0,
    0, 42,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 0,  0,  0,  0,  0,  0,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,-38,  0,132,134,  0,  0,  0,136,138,  0,  0,  0,143,  0,  0,  0,  0,140,  0,  0,  0,  0,  0,  0,144,  0,  0,  0,146, 76,148, 78,  0, 0, 80, 83, 85,149,150,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0,46, 0,67,68,69,70,71, 0,43,130, 0, 0,129,128,121,116,111,102,97,94,91,88,74,145,147, 0,
    0, 44,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 0,  0,  0,  0,  0,  0,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,-37,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,-37,  0,  0,  0,  0,  0,  0,  0, 0,  0,  0,  0,  0,  0,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,-31,-31,-31,-31,  0,  0,  0,-31,-31,  0,  0,  0,-31,  0,  0,  0,  0,-31,  0,  0,  0,  0,  0,  0,-31,-31,-31,-31,-31,-31,-31,-31,  0, 0,-31,-31,-31,-31,-31,-31, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0,  0,132,134,  0,  0,  0,136,138,  0,  0,  0,143,  0,  0,  0,  0,140,  0,  0,  0,  0,  0,  0,144,  0, 60,  0,146, 63,148, 78,  0, 0, 80, 83, 85,149,150, 82, 0,  0, 0, 0, 62, 0, 0, 0, 0,47,54, 0,55,57,58,67,68,69,70,71,59, 0,130, 0, 0,129,128,121,116,111,102,97,94,91,88,74,145,147, 0,
    0,-30,-30,-30,-30,  0,  0,  0,-30,-30,  0,  0,  0,-30,  0,  0,  0,  0,-30,  0,  0,  0,  0,  0,  0,-30,-30,-30,-30,-30,-30,-30,-30, 48, 0,-30,-30,-30,-30,-30,-30, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,-18,-18,-18,-18,  0,  0,  0,-18,-18,  0,  0,  0,-18,  0,  0,  0,  0,-18,  0,  0,  0,  0,  0,  0,-18,-18,-18,-18,-18,-18,-18,-18,-18, 0,-18,-18,-18,-18,-18,-18, 0,-18, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 50,  0,  0,  0,  0,  0, 0,  0,  0,  0,  0,  0,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,-19,  0,  0,  0,  0,  0, 0,  0,  0,  0,  0,  0,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0,  0,132,134,  0,  0,  0,136,138,  0,  0,  0,143,  0,  0,  0,  0,140,  0,  0,  0,  0,  0,  0,144,  0, 60,-20,146, 63,148, 78,  0, 0, 80, 83, 85,149,150, 82, 0,  0, 0, 0, 62, 0, 0, 0, 0,53,54,52,55,57,58,67,68,69,70,71,59, 0,130, 0, 0,129,128,121,116,111,102,97,94,91,88,74,145,147, 0,
    0,-13,-13,-13,-13,  0,  0,  0,-13,-13,  0,  0,  0,-13,  0,  0,  0,  0,-13,  0,  0,  0,  0,  0,  0,-13,-13,-13,-13,-13,-13,-13,-13,-13, 0,-13,-13,-13,-13,-13,-13, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,-14,-14,-14,-14,  0,  0,  0,-14,-14,  0,  0,  0,-14,  0,  0,  0,  0,-14,  0,  0,  0,  0,  0,  0,-14,-14,-14,-14,-14,-14,-14,-14,-14, 0,-14,-14,-14,-14,-14,-14, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,-28,-28,-28,-28,  0,  0,  0,-28,-28,  0,  0,  0,-28,  0,  0,  0,  0,-28,  0,  0,  0,  0,  0,  0,-28,-28,-28,-28,-28,-28,-28,-28,-28, 0,-28,-28,-28,-28,-28,-28, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0, 56,-15,-15,-15,  0,  0,  0,-15,-15,  0,  0,  0,-15,  0,  0,  0,  0,-15,  0,  0,  0,  0,  0,  0,-15,-15,-15,-15,-15,-15,-15,-15,-15, 0,-15,-15,-15,-15,-15,-15, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,-16,-16,-16,-16,  0,  0,  0,-16,-16,  0,  0,  0,-16,  0,  0,  0,  0,-16,  0,  0,  0,  0,  0,  0,-16,-16,-16,-16,-16,-16,-16,-16,-16, 0,-16,-16,-16,-16,-16,-16, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,-17,-17,-17,-17,  0,  0,  0,-17,-17,  0,  0,  0,-17,  0,  0,  0,  0,-17,  0,  0,  0,  0,  0,  0,-17,-17,-17,-17,-17,-17,-17,-17,-17, 0,-17,-17,-17,-17,-17,-17, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0,  0,132,134,  0,  0,  0,136,138,  0,  0,  0,143,  0,  0,  0,  0,140,  0,  0,  0,  0,  0,  0,144,  0, 60,-20,146, 63,148, 78,  0, 0, 80, 83, 85,149,150, 82, 0,  0, 0, 0, 62, 0, 0, 0, 0,53,54,51,55,57,58,67,68,69,70,71,59, 0,130, 0, 0,129,128,121,116,111,102,97,94,91,88,74,145,147, 0,
  151,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 0,  0,  0,  0,  0,  0,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 61,  0,  0,  0, 0,  0,  0,  0,  0,  0,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
   75,-81,-81,-81,-81,-81,-81,-81,-81,-81,-81,-81,-81,-81,-81,-81,-81,-81,-81,-81,-81,-81,-81,-81,-81,141,-81,-81,-81,-81,-81,-81,-81,-81, 0,-81,-81,-81,-81,-81,-81, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0,  0,132,134,  0,  0,  0,136,138,  0,  0,  0,143,  0,  0,  0,  0,140,  0,  0,  0,  0,  0,  0,144,  0, 60,  0,146, 63,148, 78,  0, 0, 80, 83, 85,149,150, 82, 0,  0, 0, 0, 62, 0, 0, 0, 0,49,54, 0,55,57,58,67,68,69,70,71,59, 0,130, 0, 0,129,128,121,116,111,102,97,94,91,88,74,145,147, 0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 64,  0,  0,  0,  0,  0,  0,  0, 0,  0,  0,  0,  0,  0,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,-29,-29,-29,-29,  0,  0,  0,-29,-29,  0,  0,  0,-29,  0,  0,  0,  0,-29,  0,  0,  0,  0,  0,  0,-29,-29,-29,-29,-29,-29,-29,-29,-29, 0,-29,-29,-29,-29,-29,-29, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,-22,-22,-22,-22,  0,  0,  0,-22,-22,  0,  0,  0,-22,  0,  0,  0,  0,-22,  0,  0,  0,  0,  0,  0,-22,-22,-22,-22,-22,-22,-22,-22,-22, 0,-22,-22,-22,-22,-22,-22, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,-23,-23,-23,-23,  0,  0,  0,-23,-23,  0,  0,  0,-23,  0,  0,  0,  0,-23,  0,  0,  0,  0,  0,  0,-23,-23,-23,-23,-23,-23,-23,-23,-23, 0,-23,-23,-23,-23,-23,-23, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,-24,-24,-24,-24,  0,  0,  0,-24,-24,  0,  0,  0,-24,  0,  0,  0,  0,-24,  0,  0,  0,  0,  0,  0,-24,-24,-24,-24,-24,-24,-24,-24,-24, 0,-24,-24,-24,-24,-24,-24, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,-25,-25,-25,-25,  0,  0,  0,-25,-25,  0,  0,  0,-25,  0,  0,  0,  0,-25,  0,  0,  0,  0,  0,  0,-25,-25,-25,-25,-25,-25,-25,-25,-25, 0,-25,-25,-25,-25,-25,-25, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,-26,-26,-26,-26,  0,  0,  0,-26,-26,  0,  0,  0,-26,  0,  0,  0,  0,-26,  0,  0,  0,  0,  0,  0,-26,-26,-26,-26,-26,-26,-26,-26,-26, 0,-26,-26,-26,-26,-26,-26, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,-80,-80,-80,-80,  0,  0,  0,-80,-80,  0,  0,  0,-80,  0,  0, 87,-80,-80,  0,  0,  0,  0,  0,  0,-80,-80,-80,-80,-80,-80,-80,-80,-80, 0,-80,-80,-80,-80,-80,-80, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0,  0,132,134,  0,  0,  0,136,138,  0,  0,  0,143,  0,  0,  0,  0,140,  0,  0,  0,  0,  0,  0,144,  0,  0,  0,146,142,148,  0,  0, 0,  0,  0,  0,149,150,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,130, 0, 0,129,128,121,116,111,102,97,94,91,72, 0,145,147, 0,
    0,-27,-27,-27,-27,  0,  0,  0,-27,-27,  0,  0,  0,-27,  0,  0,  0, 73,-27,  0,  0,  0,  0,  0,  0,-27,-27,-27,-27,-27,-27,-27,-27,-27, 0,-27,-27,-27,-27,-27,-27, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0,  0,132,134,  0,  0,  0,136,138,  0,  0,  0,143,  0,  0,  0,  0,140,  0,  0,  0,  0,  0,  0,144,  0,  0,  0,146, 76,148, 78,  0, 0, 80, 83, 85,149,150,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0,66, 0,67,68,69,70,71, 0, 0,130, 0, 0,129,128,121,116,111,102,97,94,91,88,74,145,147, 0,
   75,-81,-81,-81,-81,-81,-81,-81,-81,-81,-81,-81,-81,-81,-81,-81,-81,-81,-81,-81,-81,-81,-81,-81,-81,141,-81,-81,-81,-81,-81,-81,-81,-81, 0,-81,-81,-81,-81,-81,-81, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0,  0,132,134,  0,  0,  0,136,138,  0,  0,  0,143,  0,  0,  0,  0,140,  0,  0,  0,  0,  0,  0,144,  0,  0,  0,146, 76,148, 78,  0, 0, 80, 83, 85,149,150,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0,65, 0,67,68,69,70,71, 0, 0,130, 0, 0,129,128,121,116,111,102,97,94,91,88,74,145,147, 0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 77,  0,  0,  0,  0,  0,  0,  0,  0, 0,  0,  0,  0,  0,  0,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,-38,  0,132,134,  0,  0,  0,136,138,  0,  0,  0,143,  0,  0,  0,  0,140,  0,  0,  0,  0,  0,  0,144,  0,  0,  0,146, 76,148, 78,  0, 0, 80, 83, 85,149,150,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0,46, 0,67,68,69,70,71, 0,45,130, 0, 0,129,128,121,116,111,102,97,94,91,88,74,145,147, 0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 79,  0,  0,  0,  0,  0,  0,  0,  0, 0,  0,  0,  0,  0,  0,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0,  0,132,134,  0,  0,  0,136,138,  0,  0,  0,143,  0,  0,  0,  0,140,  0,  0,  0,  0,  0,  0,144,  0,  0,  0, 36, 76,148, 78,  0, 0, 80, 83, 85,149,150,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0,38, 0,67,68,69,70,71, 0, 0,130, 0, 0,129,128,121,116,111,102,97,94,91,88,74,145,147, 0,
    0,-38,  0,132,134,  0,  0,  0,136,138,  0,  0,  0,143,  0,  0,  0,  0,140,  0,  0,  0,  0,  0,  0, 81,  0,  0,  0,146, 76,148, 78,  0, 0, 80, 83, 85,149,150,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0,46, 0,67,68,69,70,71, 0,32,130, 0, 0,129,128,121,116,111,102,97,94,91,88,74,145,147, 0,
    0,  0,  0,132,134,  0,  0,  0,136,138,  0,  0,  0,143,  0,  0,  0,  0,140,  0,  0,  0,  0,  0,  0,144,  0, 60,  0,146, 63,148, 78,  0, 0, 80, 83, 85,149,150, 82, 0,  0, 0, 0, 62, 0, 0, 0, 0,30,54, 0,55,57,58,67,68,69,70,71,59, 0,130, 0, 0,129,128,121,116,111,102,97,94,91,88,74,145,147, 0,
    0,  0,  0,132,134,  0,  0,  0,136,138,  0,  0,  0,143,  0,  0,  0,  0,140,  0,  0,  0,  0,  0,  0,144,  0,  0,  0,146, 76,148, 78,  0, 0, 80, 83, 85,149,150,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0,29, 0,67,68,69,70,71, 0, 0,130, 0, 0,129,128,121,116,111,102,97,94,91,88,74,145,147, 0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 84,  0,  0,  0,  0,  0,  0,  0,  0, 0,  0,  0,  0,  0,  0,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,-78,-78,-78,-78,  0,  0,  0,-78,-78,  0, 90,  0,-78,  0,  0,-78,-78,-78,  0,  0,  0,  0,  0,  0,-78,-78,-78,-78,-78,-78,-78,-78,-78, 0,-78,-78,-78,-78,-78,-78, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0,  0,132,134,  0,  0,  0,136,138,  0,  0,  0,143,  0,  0,  0,  0,140,  0,  0,  0,  0,  0,  0,144,  0,  0,  0,146,142,148,  0,  0, 0,  0,  0,  0,149,150,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,130, 0, 0,129,128,121,116,111,102,97,94,86, 0, 0,145,147, 0,
    0,-79,-79,-79,-79,  0,  0,  0,-79,-79,  0,  0,  0,-79,  0,  0, 87,-79,-79,  0,  0,  0,  0,  0,  0,-79,-79,-79,-79,-79,-79,-79,-79,-79, 0,-79,-79,-79,-79,-79,-79, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,-76,-76,-76,-76,  0,  0,  0,-76,-76,  0,-76, 93,-76,  0,  0,-76,-76,-76,  0,  0,  0,  0,  0,  0,-76,-76,-76,-76,-76,-76,-76,-76,-76, 0,-76,-76,-76,-76,-76,-76, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0,  0,132,134,  0,  0,  0,136,138,  0,  0,  0,143,  0,  0,  0,  0,140,  0,  0,  0,  0,  0,  0,144,  0,  0,  0,146,142,148,  0,  0, 0,  0,  0,  0,149,150,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,130, 0, 0,129,128,121,116,111,102,97,89, 0, 0, 0,145,147, 0,
    0,-77,-77,-77,-77,  0,  0,  0,-77,-77,  0, 90,  0,-77,  0,  0,-77,-77,-77,  0,  0,  0,  0,  0,  0,-77,-77,-77,-77,-77,-77,-77,-77,-77, 0,-77,-77,-77,-77,-77,-77, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,-74,-74,-74,-74,  0,  0,  0,-74,-74, 96,-74,-74,-74,  0,  0,-74,-74,-74,  0,  0,  0,  0,  0,  0,-74,-74,-74,-74,-74,-74,-74,-74,-74, 0,-74,-74,-74,-74,-74,-74, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0,  0,132,134,  0,  0,  0,136,138,  0,  0,  0,143,  0,  0,  0,  0,140,  0,  0,  0,  0,  0,  0,144,  0,  0,  0,146,142,148,  0,  0, 0,  0,  0,  0,149,150,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,130, 0, 0,129,128,121,116,111,102,92, 0, 0, 0, 0,145,147, 0,
    0,-75,-75,-75,-75,  0,  0,  0,-75,-75,  0,-75, 93,-75,  0,  0,-75,-75,-75,  0,  0,  0,  0,  0,  0,-75,-75,-75,-75,-75,-75,-75,-75,-75, 0,-75,-75,-75,-75,-75,-75, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,-72,-72,-72,-72,  0,  0,  0,-72,-72,-72,-72,-72,-72,  0,  0,-72,-72,-72, 99,101,  0,  0,  0,  0,-72,-72,-72,-72,-72,-72,-72,-72,-72, 0,-72,-72,-72,-72,-72,-72, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0,  0,132,134,  0,  0,  0,136,138,  0,  0,  0,143,  0,  0,  0,  0,140,  0,  0,  0,  0,  0,  0,144,  0,  0,  0,146,142,148,  0,  0, 0,  0,  0,  0,149,150,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,130, 0, 0,129,128,121,116,111, 95, 0, 0, 0, 0, 0,145,147, 0,
    0,-73,-73,-73,-73,  0,  0,  0,-73,-73, 96,-73,-73,-73,  0,  0,-73,-73,-73,  0,  0,  0,  0,  0,  0,-73,-73,-73,-73,-73,-73,-73,-73,-73, 0,-73,-73,-73,-73,-73,-73, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,-69,-69,-69,-69,  0,  0,  0,-69,-69,-69,-69,-69,-69,  0,  0,-69,-69,-69,-69,-69,108,104,110,106,-69,-69,-69,-69,-69,-69,-69,-69,-69, 0,-69,-69,-69,-69,-69,-69, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0,  0,132,134,  0,  0,  0,136,138,  0,  0,  0,143,  0,  0,  0,  0,140,  0,  0,  0,  0,  0,  0,144,  0,  0,  0,146,142,148,  0,  0, 0,  0,  0,  0,149,150,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,130, 0, 0,129,128,121,116, 98,  0, 0, 0, 0, 0, 0,145,147, 0,
    0,-70,-70,-70,-70,  0,  0,  0,-70,-70,-70,-70,-70,-70,  0,  0,-70,-70,-70,-70,-70,108,104,110,106,-70,-70,-70,-70,-70,-70,-70,-70,-70, 0,-70,-70,-70,-70,-70,-70, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0,  0,132,134,  0,  0,  0,136,138,  0,  0,  0,143,  0,  0,  0,  0,140,  0,  0,  0,  0,  0,  0,144,  0,  0,  0,146,142,148,  0,  0, 0,  0,  0,  0,149,150,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,130, 0, 0,129,128,121,116,100,  0, 0, 0, 0, 0, 0,145,147, 0,
    0,-71,-71,-71,-71,  0,  0,  0,-71,-71,-71,-71,-71,-71,  0,  0,-71,-71,-71, 99,101,  0,  0,  0,  0,-71,-71,-71,-71,-71,-71,-71,-71,-71, 0,-71,-71,-71,-71,-71,-71, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,-64,-64,-64,-64,  0,  0,  0,-64,-64,-64,-64,-64,-64,115,113,-64,-64,-64,-64,-64,-64,-64,-64,-64,-64,-64,-64,-64,-64,-64,-64,-64,-64, 0,-64,-64,-64,-64,-64,-64, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0,  0,132,134,  0,  0,  0,136,138,  0,  0,  0,143,  0,  0,  0,  0,140,  0,  0,  0,  0,  0,  0,144,  0,  0,  0,146,142,148,  0,  0, 0,  0,  0,  0,149,150,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,130, 0, 0,129,128,121,103,  0,  0, 0, 0, 0, 0, 0,145,147, 0,
    0,-65,-65,-65,-65,  0,  0,  0,-65,-65,-65,-65,-65,-65,115,113,-65,-65,-65,-65,-65,-65,-65,-65,-65,-65,-65,-65,-65,-65,-65,-65,-65,-65, 0,-65,-65,-65,-65,-65,-65, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0,  0,132,134,  0,  0,  0,136,138,  0,  0,  0,143,  0,  0,  0,  0,140,  0,  0,  0,  0,  0,  0,144,  0,  0,  0,146,142,148,  0,  0, 0,  0,  0,  0,149,150,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,130, 0, 0,129,128,121,105,  0,  0, 0, 0, 0, 0, 0,145,147, 0,
    0,-66,-66,-66,-66,  0,  0,  0,-66,-66,-66,-66,-66,-66,115,113,-66,-66,-66,-66,-66,-66,-66,-66,-66,-66,-66,-66,-66,-66,-66,-66,-66,-66, 0,-66,-66,-66,-66,-66,-66, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0,  0,132,134,  0,  0,  0,136,138,  0,  0,  0,143,  0,  0,  0,  0,140,  0,  0,  0,  0,  0,  0,144,  0,  0,  0,146,142,148,  0,  0, 0,  0,  0,  0,149,150,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,130, 0, 0,129,128,121,107,  0,  0, 0, 0, 0, 0, 0,145,147, 0,
    0,-67,-67,-67,-67,  0,  0,  0,-67,-67,-67,-67,-67,-67,115,113,-67,-67,-67,-67,-67,-67,-67,-67,-67,-67,-67,-67,-67,-67,-67,-67,-67,-67, 0,-67,-67,-67,-67,-67,-67, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0,  0,132,134,  0,  0,  0,136,138,  0,  0,  0,143,  0,  0,  0,  0,140,  0,  0,  0,  0,  0,  0,144,  0,  0,  0,146,142,148,  0,  0, 0,  0,  0,  0,149,150,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,130, 0, 0,129,128,121,109,  0,  0, 0, 0, 0, 0, 0,145,147, 0,
    0,-68,-68,-68,-68,  0,  0,  0,-68,-68,-68,-68,-68,-68,  0,  0,-68,-68,-68,-68,-68,108,104,110,106,-68,-68,-68,-68,-68,-68,-68,-68,-68, 0,-68,-68,-68,-68,-68,-68, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,-61,-61,-61,-61,  0,  0,  0,-61,-61,-61,-61,-61,-61,-61,-61,-61,-61,-61,-61,-61,-61,-61,-61,-61,-61,-61,-61,-61,-61,-61,-61,-61,-61, 0,-61,-61,-61,-61,-61,-61, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0,  0,132,134,  0,  0,  0,136,138,  0,  0,  0,143,  0,  0,  0,  0,140,  0,  0,  0,  0,  0,  0,144,  0,  0,  0,146,142,148,  0,  0, 0,  0,  0,  0,149,150,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,130, 0, 0,129,128,112,  0,  0,  0, 0, 0, 0, 0, 0,145,147, 0,
    0,-62,-62,-62,-62,  0,  0,  0,-62,-62,-62,-62,-62,-62,-62,-62,-62,-62,-62,-62,-62,-62,-62,-62,-62,-62,-62,-62,-62,-62,-62,-62,-62,-62, 0,-62,-62,-62,-62,-62,-62, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0,  0,132,134,  0,  0,  0,136,138,  0,  0,  0,143,  0,  0,  0,  0,140,  0,  0,  0,  0,  0,  0,144,  0,  0,  0,146,142,148,  0,  0, 0,  0,  0,  0,149,150,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,130, 0, 0,129,128,114,  0,  0,  0, 0, 0, 0, 0, 0,145,147, 0,
    0,-63,-63,-63,-63,  0,  0,  0,-63,-63,-63,-63,-63,-63,115,113,-63,-63,-63,-63,-63,-63,-63,-63,-63,-63,-63,-63,-63,-63,-63,-63,-63,-63, 0,-63,-63,-63,-63,-63,-63, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,-58,-58,-58,-58,123,125,127,-58,-58,-58,-58,-58,-58,-58,-58,-58,-58,-58,-58,-58,-58,-58,-58,-58,-58,-58,-58,-58,-58,-58,-58,-58,-58, 0,-58,-58,-58,-58,-58,-58, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0,  0,132,134,  0,  0,  0,136,138,  0,  0,  0,143,  0,  0,  0,  0,140,  0,  0,  0,  0,  0,  0,144,  0,  0,  0,146,142,148,  0,  0, 0,  0,  0,  0,149,150,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,130, 0, 0,129,117,  0,  0,  0,  0, 0, 0, 0, 0, 0,145,147, 0,
    0,-59,-59,-59,-59,123,125,127,-59,-59,-59,-59,-59,-59,-59,-59,-59,-59,-59,-59,-59,-59,-59,-59,-59,-59,-59,-59,-59,-59,-59,-59,-59,-59, 0,-59,-59,-59,-59,-59,-59, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0,  0,132,134,  0,  0,  0,136,138,  0,  0,  0,143,  0,  0,  0,  0,140,  0,  0,  0,  0,  0,  0,144,  0,  0,  0,146,142,148,  0,  0, 0,  0,  0,  0,149,150,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,130, 0, 0,129,119,  0,  0,  0,  0, 0, 0, 0, 0, 0,145,147, 0,
    0,-60,-60,118,120,  0,  0,  0,-60,-60,-60,-60,-60,-60,-60,-60,-60,-60,-60,-60,-60,-60,-60,-60,-60,-60,-60,-60,-60,-60,-60,-60,-60,-60, 0,-60,-60,-60,-60,-60,-60, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,-54,-54,-54,-54,-54,-54,-54,-54,-54,-54,-54,-54,-54,-54,-54,-54,-54,-54,-54,-54,-54,-54,-54,-54,-54,-54,-54,-54,-54,-54,-54,-54,-54, 0,-54,-54,-54,-54,-54,-54, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0,  0,132,134,  0,  0,  0,136,138,  0,  0,  0,143,  0,  0,  0,  0,140,  0,  0,  0,  0,  0,  0,144,  0,  0,  0,146,142,148,  0,  0, 0,  0,  0,  0,149,150,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,130, 0, 0,122,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,145,147, 0,
    0,-55,-55,-55,-55,-55,-55,-55,-55,-55,-55,-55,-55,-55,-55,-55,-55,-55,-55,-55,-55,-55,-55,-55,-55,-55,-55,-55,-55,-55,-55,-55,-55,-55, 0,-55,-55,-55,-55,-55,-55, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0,  0,132,134,  0,  0,  0,136,138,  0,  0,  0,143,  0,  0,  0,  0,140,  0,  0,  0,  0,  0,  0,144,  0,  0,  0,146,142,148,  0,  0, 0,  0,  0,  0,149,150,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,130, 0, 0,124,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,145,147, 0,
    0,-56,-56,-56,-56,-56,-56,-56,-56,-56,-56,-56,-56,-56,-56,-56,-56,-56,-56,-56,-56,-56,-56,-56,-56,-56,-56,-56,-56,-56,-56,-56,-56,-56, 0,-56,-56,-56,-56,-56,-56, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0,  0,132,134,  0,  0,  0,136,138,  0,  0,  0,143,  0,  0,  0,  0,140,  0,  0,  0,  0,  0,  0,144,  0,  0,  0,146,142,148,  0,  0, 0,  0,  0,  0,149,150,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,130, 0, 0,126,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,145,147, 0,
    0,-57,-57,-57,-57,123,125,127,-57,-57,-57,-57,-57,-57,-57,-57,-57,-57,-57,-57,-57,-57,-57,-57,-57,-57,-57,-57,-57,-57,-57,-57,-57,-57, 0,-57,-57,-57,-57,-57,-57, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,-53,-53,-53,-53,-53,-53,-53,-53,-53,-53,-53,-53,-53,-53,-53,-53,-53,-53,-53,-53,-53,-53,-53,-53,-53,-53,-53,-53,-53,-53,-53,-53,-53, 0,-53,-53,-53,-53,-53,-53, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,-46,-46,-46,-46,-46,-46,-46,-46,-46,-46,-46,-46,-46,-46,-46,-46,-46,-46,-46,-46,-46,-46,-46,-46,-46,-46,-46,-46,-46,-46,-46,-46,-46, 0,-46,-46,-46,-46,-46,-46, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,-47,-47,-47,-47,-47,-47,-47,-47,-47,-47,-47,-47,-47,-47,-47,-47,-47,-47,-47,-47,-47,-47,-47,-47,-47,-47,-47,-47,-47,-47,-47,-47,-47, 0,-47,-47,-47,-47,-47,-47, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,144,  0,  0,  0,146,142,148,  0,  0, 0,  0,  0,  0,149,150,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,131, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,145,147, 0,
    0,-48,-48,-48,-48,-48,-48,-48,-48,-48,-48,-48,-48,-48,-48,-48,-48,-48,-48,-48,-48,-48,-48,-48,-48,-48,-48,-48,-48,-48,-48,-48,-48,-48, 0,-48,-48,-48,-48,-48,-48, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,144,  0,  0,  0,146,142,148,  0,  0, 0,  0,  0,  0,149,150,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,133, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,145,147, 0,
    0,-49,-49,-49,-49,-49,-49,-49,-49,-49,-49,-49,-49,-49,-49,-49,-49,-49,-49,-49,-49,-49,-49,-49,-49,-49,-49,-49,-49,-49,-49,-49,-49,-49, 0,-49,-49,-49,-49,-49,-49, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,144,  0,  0,  0,146,142,148,  0,  0, 0,  0,  0,  0,149,150,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,135, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,145,147, 0,
    0,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50, 0,-50,-50,-50,-50,-50,-50, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,144,  0,  0,  0,146,142,148,  0,  0, 0,  0,  0,  0,149,150,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,137, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,145,147, 0,
    0,-51,-51,-51,-51,-51,-51,-51,-51,-51,-51,-51,-51,-51,-51,-51,-51,-51,-51,-51,-51,-51,-51,-51,-51,-51,-51,-51,-51,-51,-51,-51,-51,-51, 0,-51,-51,-51,-51,-51,-51, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,144,  0,  0,  0,146,142,148,  0,  0, 0,  0,  0,  0,149,150,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,139, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,145,147, 0,
    0,  0,  0,132,134,  0,  0,  0,136,138,  0,  0,  0,143,  0,  0,  0,  0,140,  0,  0,  0,  0,  0,  0,144,-43,  0,  0,146, 76,148, 78,  0, 0, 80, 83, 85,149,150,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0,26, 0,67,68,69,70,71, 0, 0,130,21, 0,129,128,121,116,111,102,97,94,91,88,74,145,147, 0,
    0,-81,-81,-81,-81,-81,-81,-81,-81,-81,-81,-81,-81,-81,-81,-81,-81,-81,-81,-81,-81,-81,-81,-81,-81,141,-81,-81,-81,-81,-81,-81,-81,-81, 0,-81,-81,-81,-81,-81,-81, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,144,  0,  0,  0,146,142,148,  0,  0, 0,  0,  0,  0,149,150,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,145,147, 0,
    0,  0,  0,132,134,  0,  0,  0,136,138,  0,  0,  0,143,  0,  0,  0,  0,140,  0,  0,  0,  0,  0,  0,144,  0,  0,  0,146, 76,148, 78,  0, 0, 80, 83, 85,149,150,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0,38, 0,67,68,69,70,71, 0, 0,130, 0, 0,129,128,121,116,111,102,97,94,91,88,74,145,147, 0,
    0,-41,-41,-41,-41,-41,-41,-41,-41,-41,-41,-41,-41,-41,-41,-41,-41,-41,-41,-41,-41,-41,-41,-41,-41,-41,-41,-41,-41,-41,-41,-41,-41,-41, 0,-41,-41,-41,-41,-41,-41, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,-82,-82,-82,-82,-82,-82,-82,-82,-82,-82,-82,-82,-82,-82,-82,-82,-82,-82,-82,-82,-82,-82,-82,-82,-82,-82,-82,-82,-82,-82,-82,-82,-82, 0,-82,-82,-82,-82,-82,-82, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,-83,-83,-83,-83,-83,-83,-83,-83,-83,-83,-83,-83,-83,-83,-83,-83,-83,-83,-83,-83,-83,-83,-83,-83,-83,-83,-83,-83,-83,-83,-83,-83,-83, 0,-83,-83,-83,-83,-83,-83, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,-84,-84,-84,-84,-84,-84,-84,-84,-84,-84,-84,-84,-84,-84,-84,-84,-84,-84,-84,-84,-84,-84,-84,-84,-84,-84,-84,-84,-84,-84,-84,-84,-84, 0,-84,-84,-84,-84,-84,-84, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,-85,-85,-85,-85,-85,-85,-85,-85,-85,-85,-85,-85,-85,-85,-85,-85,-85,-85,-85,-85,-85,-85,-85,-85,-85,-85,-85,-85,-85,-85,-85,-85,-85, 0,-85,-85,-85,-85,-85,-85, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,-86,-86,-86,-86,-86,-86,-86,-86,-86,-86,-86,-86,-86,-86,-86,-86,-86,-86,-86,-86,-86,-86,-86,-86,-86,-86,-86,-86,-86,-86,-86,-86,-86, 0,-86,-86,-86,-86,-86,-86, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0,  0,132,134,  0,  0,  0,136,138,  0,  0,  0,143,  0,  0,  0,  0,140,  0,  0,  0,  0,  0,  0,144,  0,  0,  0,146, 76,148, 78,  0, 0, 80, 83, 85,149,150,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0,18, 0,67,68,69,70,71, 0, 0,130, 0, 0,129,128,121,116,111,102,97,94,91,88,74,145,147, 0,
  151,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 16,  0,  0,  0,  0,  0,  0,  0,  0, 0,  0,  0,  0,  0,  0,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,152,  0,  0,  0, 0,  0,  0,  0,  0,  0,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, -6,  0,  0,  0, 0,  0,  0,  0,  0,  0,  0, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0,  0,  0, 0,
};
static const size_t carb_production_lengths[] = {
  1,
  2,
  0,
  1,
  1,
  1,
  6,
  2,
  0,
  3,
  0,
  2,
  1,
  1,
  1,
  1,
  1,
  3,
  2,
  0,
  5,
  1,
  1,
  1,
  1,
  1,
  1,
  2,
  3,
  5,
  7,
  9,
  2,
  5,
  3,
  6,
  1,
  0,
  3,
  4,
  1,
  2,
  0,
  3,
  0,
  1,
  2,
  2,
  2,
  2,
  2,
  2,
  1,
  3,
  3,
  3,
  1,
  3,
  3,
  1,
  3,
  3,
  1,
  3,
  3,
  3,
  3,
  1,
  3,
  3,
  1,
  3,
  1,
  3,
  1,
  3,
  1,
  3,
  1,
  3,
  1,
  1,
  1,
  1,
  1,
  1
};
static const int carb_production_syms[] = {
  82,
  46,
  46,
  47,
  47,
  48,
  49,
  50,
  50,
  51,
  51,
  52,
  53,
  53,
  53,
  53,
  53,
  54,
  55,
  55,
  56,
  57,
  57,
  57,
  57,
  57,
  57,
  58,
  59,
  60,
  60,
  61,
  62,
  63,
  64,
  64,
  65,
  65,
  66,
  66,
  66,
  67,
  67,
  68,
  68,
  69,
  69,
  69,
  69,
  69,
  69,
  69,
  70,
  70,
  70,
  70,
  71,
  71,
  71,
  72,
  72,
  72,
  73,
  73,
  73,
  73,
  73,
  74,
  74,
  74,
  75,
  75,
  76,
  76,
  77,
  77,
  78,
  78,
  79,
  79,
  80,
  80,
  80,
  80,
  81,
  81
};

#ifndef CARB_CARB_CLANGSRCCOMPILERPARSE_H_INCLUDED
struct carb_stack {
  int error_recovery_:1;
  int pending_reset_:1;
  int discard_remaining_actions_:1;
  int slot_1_has_sym_data_:1;
  int slot_1_has_common_data_:1;
  int top_of_stack_has_sym_data_:1;
  int top_of_stack_has_common_data_:1;
  int need_sym_:1;
  int is_final_input_:1;
  int slot_0_has_current_sym_data_:1;
  int slot_0_has_common_data_:1;
  int current_sym_;
  size_t input_size_;
  const char *input_;
  int newbuf_pos_has_common_data_:1;
  int newbuf_pos_has_sym_data_:1;
  int stack_newbuf_pos_has_common_data_:1;
  int stack_newbuf_pos_has_sym_data_:1;
  int slot_1_sym_;
  int continue_at_;
  int mute_error_turns_;
  size_t pos_, num_stack_allocated_;
  struct carb_sym_data *stack_;
  struct carb_sym_data *sym_data_;
  struct carb_sym_data *new_buf_;
  size_t new_buf_num_allocated_;
  size_t new_buf_sym_partial_pos_;
  size_t current_production_length_;
  int current_production_nonterminal_;
  size_t sym_idx_;
  size_t scan_state_;
  size_t current_mode_start_state_;
  size_t match_index_;
  size_t best_match_action_;
  size_t best_match_size_;
  size_t input_index_;
  size_t input_offset_;
  size_t match_buffer_size_;
  size_t match_buffer_size_allocated_;
  /* offset, line and column at the start of match_buffer_ */
  size_t match_offset_;
  int match_line_;
  int match_col_;
  /* offset, line and column at the zero-termination (best_match_size_) of a match 
  * in match_buffer_ (the actual buffer may well be longer.) */
  size_t best_match_offset_;
  int best_match_line_;
  int best_match_col_;
  size_t token_size_;
  char *match_buffer_;
  char terminator_repair_;
  int input_line_;
  int input_col_;
  int sym_grp_;
  char codepoint_[4];
  char *cp_;
};
#define _CARB_FINISH 0
#define _CARB_MATCH 1
#define _CARB_OVERFLOW 2
#define _CARB_NO_MEMORY 3
#define _CARB_FEED_ME 4
#define _CARB_END_OF_INPUT 5
#define _CARB_SYNTAX_ERROR 6
#define _CARB_LEXICAL_ERROR 7
#define _CARB_INTERNAL_ERROR 8

#define CARB_ASSIGN 3
#define CARB_SEMICOL 4
#define CARB_COMMA 5
#define CARB_PLUS 6
#define CARB_MINUS 7
#define CARB_ASTERISK 8
#define CARB_SLASH 9
#define CARB_PERCENT 10
#define CARB_INC 11
#define CARB_DEC 12
#define CARB_AND 13
#define CARB_OR 14
#define CARB_XOR 15
#define CARB_COMP 16
#define CARB_SHR 17
#define CARB_SHL 18
#define CARB_LAND 19
#define CARB_LOR 20
#define CARB_DENY 21
#define CARB_EQUAL 22
#define CARB_NEQUAL 23
#define CARB_GREATER 24
#define CARB_LESSER 25
#define CARB_GREATEQ 26
#define CARB_LESSEQ 27
#define CARB_LPAREN 28
#define CARB_RPAREN 29
#define CARB_LCURLY 30
#define CARB_RCURLY 31
#define CARB_DECIMAL 32
#define CARB_ID 33
#define CARB_STRING 34
#define CARB_IF 35
#define CARB_ELSE 36
#define CARB_MATCH 37
#define CARB_FOR 38
#define CARB_LOOP 39
#define CARB_WHILE 40
#define CARB_TRUE 41
#define CARB_FALSE 42
#define CARB_BREAK 43
#define CARB_ERROR 44
#define CARB_INPUT_END 45

#define CARB_GLOBALS 46
#define CARB_GLOBAL 47
#define CARB_TYPE_EXPR 48
#define CARB_FUNCTION_DEF 49
#define CARB_PARAM_LIST 50
#define CARB_PARAM_LIST_TAIL 51
#define CARB_PARAM 52
#define CARB_STATEMENT 53
#define CARB_COMPOUND_STMT 54
#define CARB_STATEMENTS 55
#define CARB_VAR_DEF_STMT 56
#define CARB_EXPRESSION 57
#define CARB_EXPRESSION_STMT 58
#define CARB_ASSIGNMENT_EXPR 59
#define CARB_IF_EXPR 60
#define CARB_FOR_EXPR 61
#define CARB_LOOP_EXPR 62
#define CARB_WHILE_EXPR 63
#define CARB_BREAK_STMT 64
#define CARB_EXPR_MAYBE 65
#define CARB_PRIMARY_EXPR 66
#define CARB_ARG_LIST 67
#define CARB_ARG_LIST_TAIL 68
#define CARB_PRE_EXPR 69
#define CARB_MULTIPLICATIVE_EXPR 70
#define CARB_ADDITIVE_EXPR 71
#define CARB_SHIFT_EXPR 72
#define CARB_RELATIVE_EXPR 73
#define CARB_ABSOLUTE_EXPR 74
#define CARB_BIT_AND_EXPR 75
#define CARB_BIT_XOR_EXPR 76
#define CARB_BIT_OR_EXPR 77
#define CARB_LOGIC_AND_EXPR 78
#define CARB_LOGIC_OR_EXPR 79
#define CARB_LITERAL 80
#define CARB_BOOLEAN 81

#define M_CARB_DEFAULT 1

#endif /* CARB_CARB_CLANGSRCCOMPILERPARSE_H_INCLUDED */

void carb_stack_init(struct carb_stack *stack) {
  stack->error_recovery_ = 0;
  stack->pending_reset_ = 1;
  stack->discard_remaining_actions_ = 0;
  stack->need_sym_ = 1;
  stack->current_sym_ = 0;
  stack->input_ = NULL;
  stack->input_size_ = 0;
  stack->is_final_input_ = 0;
  stack->slot_1_has_sym_data_ = stack->slot_1_has_common_data_ = 0;
  stack->slot_1_sym_ = 0;
  stack->top_of_stack_has_sym_data_ = stack->top_of_stack_has_common_data_ = 0;
  stack->newbuf_pos_has_common_data_ = stack->newbuf_pos_has_sym_data_ = 0;
  stack->stack_newbuf_pos_has_common_data_ = stack->stack_newbuf_pos_has_sym_data_ = 0;
  stack->continue_at_ = 0;
  stack->mute_error_turns_ = 0;
  stack->pos_ = 0;
  stack->num_stack_allocated_ = 0;
  stack->stack_ = NULL;
  stack->sym_data_ = NULL;
  stack->new_buf_ = NULL;
  stack->new_buf_num_allocated_ = 0;
  stack->new_buf_sym_partial_pos_ = 0;
  stack->current_production_length_ = 0;
  stack->current_production_nonterminal_ = 0;
  stack->sym_idx_ = 0;
  stack->slot_0_has_current_sym_data_ = stack->slot_0_has_common_data_ = 0;
  stack->current_mode_start_state_ = M_CARB_DEFAULT;
  stack->scan_state_ = stack->current_mode_start_state_;
  stack->input_index_ = 0;
  stack->input_offset_ = 0;
  stack->input_line_ = 1;
  stack->input_col_ = 1;
  stack->sym_grp_ = 0;
  stack->cp_ = stack->codepoint_;
  stack->match_index_ = 0;
  stack->match_buffer_ = NULL;
  stack->match_buffer_size_ = 0;
  stack->match_buffer_size_allocated_ = 0;
  stack->terminator_repair_ = '\0';
  stack->token_size_ = 0;
  stack->match_offset_ = 0;
  stack->match_line_ = 1;
  stack->match_col_ = 1;
  stack->best_match_action_ = 0;
  stack->best_match_size_ = 0;
  stack->best_match_offset_ = 0;
  stack->best_match_line_ = 1;
  stack->best_match_col_ = 1;
}

void carb_stack_cleanup(struct carb_stack *stack) {
  if (stack->stack_) free(stack->stack_);
  if (stack->match_buffer_) free(stack->match_buffer_);
}

int carb_stack_reset(struct carb_stack *stack) {
  stack->pending_reset_ = 0;
  stack->discard_remaining_actions_ = 0;
  stack->slot_0_has_current_sym_data_ = stack->slot_0_has_common_data_ = 0;
  stack->slot_1_has_sym_data_ = stack->slot_1_has_common_data_ = 0;
  stack->slot_1_sym_ = 0;
  stack->top_of_stack_has_sym_data_ = 0;
  stack->top_of_stack_has_common_data_ = 0;
  stack->newbuf_pos_has_common_data_ = stack->newbuf_pos_has_sym_data_ = 0;
  stack->stack_newbuf_pos_has_common_data_ = stack->stack_newbuf_pos_has_sym_data_ = 0;
  stack->sym_data_ = NULL;
  stack->current_production_length_ = 0;
  stack->current_production_nonterminal_ = 0;
  stack->sym_idx_ = 0;
  stack->pos_ = 0;
  stack->error_recovery_ = 0;
  stack->need_sym_ = 1;
  stack->current_sym_ = 0;
  stack->continue_at_ = 0;
  stack->mute_error_turns_ = 0;
  /* reserve slots [0] and [1] for temporary storage of inflight syms and tokens.
  * note that initialization and lifetime of these slots is controlled by
  * flags, so no sym data constructors are called here. */
  if (stack->num_stack_allocated_ <= (stack->pos_ + 1)) {
    size_t new_num_allocated;
    if (stack->num_stack_allocated_) {
      new_num_allocated = stack->num_stack_allocated_ * 2;
      if (new_num_allocated <= stack->num_stack_allocated_) {
        /* Overflow in allocation */
        stack->continue_at_ = 0;
        return _CARB_OVERFLOW;
      }
    }
    else {
      new_num_allocated = 16;
    }
    
    if (new_num_allocated > (SIZE_MAX / sizeof(struct carb_sym_data))) {
      /* Overflow in allocation */
      stack->continue_at_ = 0;
      return _CARB_OVERFLOW;
    }
    
    void *p = realloc(stack->stack_, new_num_allocated * sizeof(struct carb_sym_data));
    if (!p) {
      /* Out of memory */
      stack->continue_at_ = 0;
      return _CARB_NO_MEMORY;
    }
    stack->stack_ = (struct carb_sym_data *)p;
    stack->num_stack_allocated_ = new_num_allocated;
  }
  stack->stack_[0].state_ = 0;
  stack->stack_[1].state_ = 0;
  stack->pos_ = 2;
  stack->scan_state_ = stack->current_mode_start_state_;
  stack->input_offset_ = 0;
  stack->input_line_ = 1;
  stack->input_col_ = 1;
  stack->match_index_ = 0;
  stack->match_buffer_size_ = 0;
  stack->terminator_repair_ = '\0';
  stack->token_size_ = 0;
  stack->match_offset_ = 0;
  stack->match_line_ = 1;
  stack->match_col_ = 1;
  stack->best_match_action_ = 0;
  stack->best_match_size_ = 0;
  stack->best_match_offset_ = 0;
  stack->best_match_line_ = 1;
  stack->best_match_col_ = 1;
  stack->sym_grp_ = 0;
  stack->cp_ = stack->codepoint_;
  return 0;
}

int carb_stack_can_recover(struct carb_stack *stack) {
  return !!stack->error_recovery_;
}

int carb_stack_accepts(struct carb_stack *stack, int sym) {
  if (!stack->pos_) return 0;
  return 0 != carb_parse_table[carb_num_columns * stack->stack_[stack->pos_ - 1].state_ + (sym - carb_minimum_sym)];}

void carb_set_mode(struct carb_stack *stack, int mode) {
  if (stack->current_mode_start_state_ == stack->scan_state_) {
    stack->scan_state_ = mode;
  }
  stack->current_mode_start_state_ = mode;
}

int carb_mode(struct carb_stack *stack) {
  return (int)stack->current_mode_start_state_;
}

static int carb_append_match_buffer(struct carb_stack *stack, const char *s, size_t len) {
  size_t size_needed = len;
  size_needed += stack->match_buffer_size_;
  if (size_needed < stack->match_buffer_size_) {
    return _CARB_OVERFLOW;
  }
  if (size_needed == SIZE_MAX) {
    /* cannot fit null terminator */
    return _CARB_OVERFLOW;
  }
  size_needed++; /* null terminator */
  if (size_needed < 128) {
    size_needed = 128;
  }
  if (size_needed > stack->match_buffer_size_allocated_) {
    /* intent of code: grow buffer size by powers of 2-1, unless our needs require more now. */
    size_t size_to_allocate = stack->match_buffer_size_allocated_ * 2 + 1;
    if (size_to_allocate <= stack->match_buffer_size_allocated_) {
      return _CARB_OVERFLOW;
    }
    if (size_to_allocate < size_needed) {
      size_to_allocate = size_needed;
    }
    void *buf = realloc(stack->match_buffer_, size_to_allocate);
    if (!buf) {
      return _CARB_NO_MEMORY;
    }
    stack->match_buffer_ = (char *)buf;
    stack->match_buffer_size_allocated_ = size_to_allocate;
  }
  
  memcpy(stack->match_buffer_ + stack->match_buffer_size_, s, len);
  stack->match_buffer_size_ += len;
  stack->match_buffer_[stack->match_buffer_size_] = '\0';
  return 0;
}

void carb_set_input(struct carb_stack *stack, const char *input, size_t input_size, int is_final_input) {
  stack->input_ = input;
  stack->input_size_ = input_size;
  stack->is_final_input_ = is_final_input;
  stack->input_index_ = 0;
}

void carb_set_location(struct carb_stack *stack, int line, int col, size_t offset) {
  if (stack->token_size_) {
    /* Parsing of next token not in progress, set end location of this token as
    ** it will be the start of the next token. */
    stack->input_line_ = stack->input_line_ - stack->best_match_line_ + line;
    stack->input_col_ = stack->input_col_ - stack->best_match_col_ + col;
    stack->input_offset_ = stack->input_offset_ - stack->best_match_offset_ + offset;
    
    stack->best_match_line_ = line;
    stack->best_match_col_ = col;
    stack->best_match_offset_ = offset;
    return;
  }
  /* Parsing of token in progress, dynamically move the start of the token, as
  ** well as the relative current partial end of the token, to the desired location. */
  stack->input_line_ = stack->input_line_ - stack->match_line_ + line;
  stack->input_col_ = stack->input_col_ - stack->match_col_ + col;
  stack->input_offset_ = stack->input_offset_ - stack->match_offset_ + offset;
  
  stack->best_match_line_ = stack->best_match_line_ - stack->match_line_ + line;
  stack->best_match_col_ = stack->best_match_col_ - stack->match_col_ + col;
  stack->best_match_offset_ = stack->best_match_offset_ - stack->match_offset_ + offset;
  stack->match_line_ = line;
  stack->match_col_ = col;
  stack->match_offset_ = offset;
}

const char *carb_text(struct carb_stack *stack) {
  return stack->match_buffer_;
}

size_t carb_len(struct carb_stack *stack) {
  return stack->token_size_;
}

int carb_line(struct carb_stack *stack) {
  return stack->match_line_;
}

int carb_column(struct carb_stack *stack) {
  return stack->match_col_;
}

size_t carb_offset(struct carb_stack *stack) {
  return stack->match_offset_;
}

int carb_endline(struct carb_stack *stack) {
  return stack->best_match_line_;
}

int carb_endcolumn(struct carb_stack *stack) {
  return stack->best_match_col_;
}

size_t carb_endoffset(struct carb_stack *stack) {
  return stack->best_match_offset_;
}

void *carb_token_common_data(struct carb_stack *stack) {
  return NULL; /* no %common_type or %common_class so this is always NULL */
}
int carb_lex(struct carb_stack *stack) {
  int r;
  unsigned char c;
  const char *input = stack->input_;
  size_t input_size = stack->input_size_;
  int is_final_input = !!stack->is_final_input_;
  size_t scan_state = stack->scan_state_;
  const int *transition_table = carb_scan_table_grouped_rex_;
  const size_t *actions = carb_scan_actions_rex;
  const size_t row_size = carb_num_scan_table_grouped_columns_;
  const size_t default_action = 0;
  const size_t start_action = 0;
  char *cp = stack->cp_;
  
  size_t match_index = stack->match_index_;
  
  size_t best_match_action = stack->best_match_action_;
  size_t best_match_size = stack->best_match_size_;
  size_t best_match_offset = stack->best_match_offset_;
  int best_match_line = stack->best_match_line_;
  int best_match_col = stack->best_match_col_;
  
  size_t input_index = stack->input_index_;
  size_t input_offset = stack->input_offset_;
  int input_line = stack->input_line_;
  int input_col = stack->input_col_;
  
  int symgrp;
  symgrp = stack->sym_grp_;
  
  /* Move any prior token out of the way */
  if (stack->token_size_) {
    stack->match_buffer_[stack->token_size_] = stack->terminator_repair_;
    
    memcpy(stack->match_buffer_, stack->match_buffer_ + stack->token_size_, stack->match_buffer_size_ - stack->token_size_);
    stack->match_buffer_size_ -= stack->token_size_;
    stack->match_offset_ = stack->best_match_offset_;
    stack->match_line_ = stack->best_match_line_;
    stack->match_col_ = stack->best_match_col_;
    
    /* Reset scanner to get ready for next token */
    stack->match_index_ = match_index = 0;
    stack->best_match_action_ = best_match_action = start_action;
    stack->best_match_size_ = best_match_size = 0;
    stack->scan_state_ = scan_state = stack->current_mode_start_state_;
    stack->token_size_ = 0;
    
  }
  
  size_t at_match_index_offset = stack->match_offset_;
  int at_match_index_line = stack->match_line_;
  int at_match_index_col = stack->match_col_;
  while (match_index < stack->match_buffer_size_) {
    c = (unsigned char)stack->match_buffer_[match_index];
    int next_sg = carb_utf8_decoder_[256 * symgrp + c];
    if (next_sg >= 0 || !~next_sg) {
      if (next_sg >= 0) {
        /* Use next_sg as the new symgroup */
        match_index++;
        symgrp = next_sg;
        *cp++ = c;
      }
      else /* (!~next_sg) */ {
        /* Invalid encoding, set next_sg to the unused codepoint group, this will 
        * induce a syntax error in the transition_table. */
        next_sg = 0;
        if (!symgrp) {
          /* Eat at least 1 byte of input, otherwise we will not make progress; but
          * the byte that triggered an encoding error on a multi-byte codepoint should
          * be reconsidered as the starting byte on a new codepoint. */
          match_index++;
          *cp++ = c;
        }
      }
      
      for (;;) {
        /* Check for start of input */
        if ((((size_t)transition_table[row_size * (1 + scan_state) - 4]) != scan_state) && (!at_match_index_offset)) {
          scan_state = (size_t)transition_table[row_size * (1 + scan_state) - 4];
        }
        /* Check for start of line */
        else if ((((size_t)transition_table[row_size * (1 + scan_state) - 3]) != scan_state) && (at_match_index_col == 1)) {
          scan_state = (size_t)transition_table[row_size * (1 + scan_state) - 3];
        }
        /* Check for end of line */
        else if ((((size_t)transition_table[row_size * (1 + scan_state) - 2]) != scan_state) && ('\n' == stack->codepoint_[0])) {
          scan_state = (size_t)transition_table[row_size * (1 + scan_state) - 2];
        }
        /* (No need to check for end of input; we have at least 1 character ahead) */
        else {
          break;
        }
      }
      size_t state_action;
      state_action = actions[scan_state];
      ptrdiff_t cp_len = cp - stack->codepoint_;
      if (state_action != default_action) /* replace with actual */ {
        best_match_action = state_action;
        best_match_size = match_index - cp_len;
        best_match_offset = at_match_index_offset;
        best_match_line = at_match_index_line;
        best_match_col = at_match_index_col;
      }
      scan_state = transition_table[row_size * scan_state + symgrp];
      /* reset decoder */
      symgrp = 0;
      cp = stack->codepoint_;
      if (scan_state) {
        at_match_index_offset += (size_t)cp_len;
        if (stack->codepoint_[0] != '\n') {
          at_match_index_col++;
        }
        else {
          at_match_index_col = 1;
          at_match_index_line++;
        }
      }
      else {
        /* error, or, end of token, depending on whether we have a match before */
        if (best_match_action == default_action) {
          goto syntax_error;
        }
        
        /* Ensure token match is null terminated */
        stack->terminator_repair_ = stack->match_buffer_[best_match_size];
        stack->match_buffer_[best_match_size] = '\0';
        stack->token_size_ = best_match_size;
        stack->best_match_action_ = best_match_action;
        stack->best_match_size_ = best_match_size;
        stack->best_match_offset_ = best_match_offset;
        stack->best_match_line_ = best_match_line;
        stack->best_match_col_ = best_match_col;
        
        stack->input_index_ = input_index;
        stack->input_offset_ = input_offset;
        stack->input_line_ = input_line;
        stack->input_col_ = input_col;
        
        stack->cp_ = cp;
        stack->sym_grp_ = symgrp;
        
        return _CARB_MATCH;
      }
    }
    else /* (next_sg < 0) */ {
      /* Partial analysis of codepoint; keep going */
      *cp++ = c;
      match_index++;
      symgrp = ~next_sg;
    }
  }
  while (input_index < input_size) {
    c = (unsigned char)input[input_index];
    int next_sg = carb_utf8_decoder_[256 * symgrp + c];
    if ((next_sg >= 0) || !~next_sg) {
      if (next_sg >= 0) {
        /* Use next_sg as the new symgroup */
        input_index++;
        symgrp = next_sg;
        *cp++ = c;
      }
      else /* (!~next_sg) */ {
        /* Invalid encoding, set next_sg to the unused codepoint group, this will 
        * induce a syntax error in the transition_table. */
        next_sg = 0;
        if (!symgrp) {
          /* Eat at least 1 byte of input, otherwise we will not make progress; but
          * the byte that triggered an encoding error on a multi-byte codepoint should
          * be reconsidered as the starting byte on a new codepoint. */
          input_index++;
          *cp++ = c;
        }
      }
      
      for (;;) {
        /* Check for start of input */
        if ((((size_t)transition_table[row_size * (1 + scan_state) - 4]) != scan_state) && (!input_offset)) {
          scan_state = (size_t)transition_table[row_size * (1 + scan_state) - 4];
        }
        /* Check for start of line */
        else if ((((size_t)transition_table[row_size * (1 + scan_state) - 3]) != scan_state) && (input_col == 1)) {
          scan_state = (size_t)transition_table[row_size * (1 + scan_state) - 3];
        }
        /* Check for end of line */
        else if ((((size_t)transition_table[row_size * (1 + scan_state) - 2]) != scan_state) && ('\n' == stack->codepoint_[0])) {
          scan_state = (size_t)transition_table[row_size * (1 + scan_state) - 2];
        }
        /* (No need to check for end of input; we have at least 1 character ahead) */
        else {
          break;
        }
      }
      size_t state_action;
      state_action = actions[scan_state];
      ptrdiff_t cp_len = cp - stack->codepoint_;
      if (state_action != default_action) /* replace with actual */ {
        best_match_action = state_action;
        best_match_size = stack->match_buffer_size_ + input_index - stack->input_index_ - cp_len;
        best_match_offset = input_offset;
        best_match_col = input_col;
        best_match_line = input_line;
      }
      scan_state = transition_table[row_size * scan_state + symgrp];
      /* Reset decoder */
      symgrp = 0;
      cp = stack->codepoint_;
      /* We advanced input_index by a codepoint and so must process line and col to keep them in sync. */
      input_offset += (size_t)cp_len;
      if (stack->codepoint_[0] != '\n') {
        input_col++;
      }
      else {
        input_col = 1;
        input_line++;
      }
      if (!scan_state) {
        /* Append from stack->input_index_ to input_index, excluding input_index itself */
        r = carb_append_match_buffer(stack, input + stack->input_index_, input_index - stack->input_index_);
        if (r) return r;
        
        if (best_match_action == default_action) {
          goto syntax_error;
        }
        
        /* Ensure token match is null terminated, note that the size we just appended may
        * (likely) be longer than the last section we matched. */
        stack->terminator_repair_ = stack->match_buffer_[best_match_size];
        stack->match_buffer_[best_match_size] = '\0';
        stack->token_size_ = best_match_size;
        stack->best_match_action_ = best_match_action;
        stack->best_match_size_ = best_match_size;
        stack->best_match_offset_ = best_match_offset;
        stack->best_match_line_ = best_match_line;
        stack->best_match_col_ = best_match_col;
        
        stack->input_index_ = input_index;
        stack->input_offset_ = input_offset;
        stack->input_line_ = input_line;
        stack->input_col_ = input_col;
        
        stack->cp_ = cp;
        stack->sym_grp_ = symgrp;
        
        return _CARB_MATCH;
      }
    }
    else /* (next_sg < 0) */ {
      /* Partial analysis of codepoint; keep going */
      *cp++ = c;
      input_index++;
      symgrp = ~next_sg;
    }
  }
  
  r = carb_append_match_buffer(stack, input + stack->input_index_, input_index - stack->input_index_);
  if (r) return r;
  
  /* Resume scanning after the input already processed. */
  match_index = stack->match_buffer_size_;
  
  if (!is_final_input) {
    /* Need more input */
    stack->scan_state_ = scan_state;
    stack->token_size_ = 0; /* no match yet */
    stack->input_index_ = input_index;
    stack->input_offset_ = input_offset;
    stack->input_line_ = input_line;
    stack->input_col_ = input_col;
    
    stack->best_match_action_ = best_match_action;
    stack->best_match_size_ = best_match_size;
    stack->best_match_offset_ = best_match_offset;
    stack->best_match_line_ = best_match_line;
    stack->best_match_col_ = best_match_col;
    
    stack->match_index_ = match_index;
    
    stack->cp_ = cp;
    stack->sym_grp_ = symgrp;
    
    return _CARB_FEED_ME;
  }
  for (;;) {
    /* Check for start of input */
    if ((((size_t)transition_table[row_size * (1 + scan_state) - 4]) != scan_state) && (!input_offset)) {
      scan_state = (size_t)transition_table[row_size * (1 + scan_state) - 4];
    }
    /* Check for start of line */
    else if ((((size_t)transition_table[row_size * (1 + scan_state) - 3]) != scan_state) && (input_col == 1)) {
      scan_state = (size_t)transition_table[row_size * (1 + scan_state) - 3];
    }
    /* Check for end of line (always true at end of input) */
    else if (((size_t)transition_table[row_size * (1 + scan_state) - 2]) != scan_state) {
      scan_state = (size_t)transition_table[row_size * (1 + scan_state) - 2];
    }
    /* Check for end of input (always true) */
    else if (((size_t)transition_table[row_size * (1 + scan_state) - 1]) != scan_state) {
      scan_state = (size_t)transition_table[row_size * (1 + scan_state) - 1];
    }
    /* (No need to check for end of input; we have at least 1 character ahead) */
    else {
      break;
    }
  }
  size_t state_action;
  state_action = actions[scan_state];
  if (state_action != default_action) /* replace with actual */ {
    best_match_action = state_action;
    best_match_size = stack->match_buffer_size_;
    best_match_offset = input_offset;
    best_match_col = input_col;
    best_match_line = input_line;
  }
  
  if (!stack->match_buffer_size_ && (stack->input_index_ == input_size)) {
    /* Exhausted all input - leave stack in a state where we can
    * immediately re-use it in its initial state */
    stack->match_index_ = 0;
    stack->best_match_action_ = best_match_action = start_action;
    stack->best_match_size_ = best_match_size;
    stack->best_match_offset_ = best_match_offset;
    stack->best_match_line_ = best_match_line;
    stack->best_match_col_ = best_match_col;
    stack->scan_state_ = scan_state = stack->current_mode_start_state_;
    
    stack->token_size_ = 0;
    stack->input_offset_ = input_offset;
    stack->input_line_ = input_line;
    stack->input_col_ = input_col;
    stack->cp_ = cp;
    stack->sym_grp_ = symgrp;
    
    return _CARB_END_OF_INPUT;
  }
  
  if (best_match_action == default_action) {
    goto syntax_error;
  }
  
  /* Ensure token match is null terminated */
  stack->terminator_repair_ = stack->match_buffer_[best_match_size];
  stack->match_buffer_[best_match_size] = '\0';
  stack->token_size_ = best_match_size;
  stack->best_match_action_ = best_match_action;
  stack->best_match_size_ = best_match_size;
  stack->best_match_offset_ = best_match_offset;
  stack->best_match_line_ = best_match_line;
  stack->best_match_col_ = best_match_col;
  
  stack->input_index_ = input_index;
  stack->input_offset_ = input_offset;
  stack->input_line_ = input_line;
  stack->input_col_ = input_col;
  stack->cp_ = cp;
  stack->sym_grp_ = symgrp;
  
  return _CARB_MATCH;
  syntax_error: {
    /* compute length of first codepoint in the match; this is not necessarily the
    * codepoint where we discovered the error. */
    size_t cp_len;
    static size_t utf8_cp_len[] = { /* 0xxxx */ 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1, 
      /* 10xxx */ 1, 1, 1, 1, 1, 1, 1, 1, /* lead byte as continuation byte is invalid encoding */
      /* 110xx */ 2, 2, 2, 2, 
      /* 1110x */ 3, 3, 
    /* 11110 */ 4 };
    if (stack->match_buffer_size_) {
      cp_len = utf8_cp_len[((unsigned char)stack->match_buffer_[0]) >> 3];
      stack->best_match_offset_ = stack->match_offset_ + cp_len;
      if (stack->match_buffer_[0] != '\n') {
        stack->best_match_line_ = stack->match_line_;
        stack->best_match_col_ = stack->match_col_ + 1;
      }
      else {
        stack->best_match_line_ = stack->match_line_ + 1;
        stack->best_match_col_ = 1;
      }
    }
    else {
      cp_len = utf8_cp_len[((unsigned char)input[stack->input_index_]) >> 3];
      /* Append the single codepoint causing the syntax error */
      r = carb_append_match_buffer(stack, input + stack->input_index_, cp_len);
      if (r) return r;
      
      input_offset++;
      if (input[stack->input_index_] != '\n') {
        input_col++;
      }
      else {
        input_col = 1;
        input_line++;
      }
      input_index = stack->input_index_ + cp_len;
      stack->best_match_offset_ = input_offset;
      stack->best_match_line_ = input_line;
      stack->best_match_col_ = input_col;
    }
    
    /* Reset scanner to get ready for next token */
    stack->token_size_ = cp_len;
    stack->terminator_repair_ = stack->match_buffer_[cp_len];
    stack->match_buffer_[cp_len] = '\0';
    
    stack->input_index_ = input_index;
    stack->input_offset_ = input_offset;
    stack->input_line_ = input_line;
    stack->input_col_ = input_col;
    stack->cp_ = cp;
    stack->sym_grp_ = symgrp;
    
    return _CARB_LEXICAL_ERROR;
  }
}

int carb_scan(struct carb_stack *stack) {
  if (stack->pending_reset_) {
    int r;
    r = carb_stack_reset(stack);
    if (r) return r;
  }
    switch (stack->continue_at_) {
    case 0: break; /* fall through to regular code path */
    case 1: goto C1;
    case 2: goto C2;
    case 3: goto C3;
    case 4: goto C4;
    case 5: goto C5;
    case 6: goto C6;
    case 7: goto C7;
    case 8: goto C8;
    case 9: goto C9;
    case 10: goto C10;
    case 11: goto C11;
    case 12: goto C12;
    case 13: goto C13;
    case 14: goto C14;
    case 15: goto C15;
    case 16: goto C16;
    case 17: goto C17;
    case 18: goto C18;
    case 19: goto C19;
    case 20: goto C20;
    case 21: goto C21;
    case 22: goto C22;
    case 23: goto C23;
    case 24: goto C24;
    case 25: goto C25;
    case 26: goto C26;
    case 27: goto C27;
    case 28: goto C28;
    case 29: goto C29;
    case 30: goto C30;
    case 31: goto C31;
    case 32: goto C32;
    case 33: goto C33;
    case 34: goto C34;
    case 35: goto C35;
    case 36: goto C36;
    case 37: goto C37;
    case 38: goto C38;
    case 39: goto C39;
    case 40: goto C40;
    case 41: goto C41;
    case 42: goto C42;
    case 43: goto C43;
    case 44: goto C44;
    case 45: goto C45;
    case 46: goto C46;
    case 47: goto C47;
    case 48: goto C48;
    case 49: goto C49;
    case 50: goto C50;
    case 51: goto C51;
    case 52: goto C52;
    case 53: goto C53;
    case 54: goto C54;
    case 55: goto C55;
    case 56: goto C56;
    case 57: goto C57;
    case 58: goto C58;
    case 59: goto C59;
    case 60: goto C60;
    case 61: goto C61;
    case 62: goto C62;
    case 63: goto C63;
    case 64: goto C64;
    case 65: goto C65;
    case 66: goto C66;
    case 67: goto C67;
    case 68: goto C68;
    case 69: goto C69;
    case 70: goto C70;
    case 71: goto C71;
    case 72: goto C72;
    case 73: goto C73;
    case 74: goto C74;
    case 75: goto C75;
    case 76: goto C76;
    case 77: goto C77;
    case 78: goto C78;
    case 79: goto C79;
    case 80: goto C80;
    case 81: goto C81;
    case 82: goto C82;
    case 83: goto C83;
    case 84: goto C84;
    case 85: goto C85;
    case 86: goto C86;
    case 87: goto C87;
    case 88: goto C88;
  } /* continuation switch */
for (;;) {
    stack->continue_at_ = 0;
    if (stack->need_sym_) {
      switch (carb_lex(stack)) {
        case _CARB_MATCH:
        stack->need_sym_ = 0;
        stack->discard_remaining_actions_ = 0;
        stack->current_sym_ = CARB_INPUT_END; /* no sym specific type associated, changed when we successfully construct it below */
        if (stack->mute_error_turns_) stack->mute_error_turns_--;
        { /* scope guard */
          switch (stack->best_match_action_) {
            case 1: /* [\ \t\n]+ */
            /* Pattern does not have a symbol */
            stack->current_sym_ = CARB_INPUT_END;
            stack->need_sym_ = 1; /* keep scanning */
            break;
            case 2: /* = */
            stack->current_sym_ = CARB_ASSIGN;
            stack->slot_0_has_current_sym_data_ = 1;
            break;
            case 3: /* \; */
            stack->current_sym_ = CARB_SEMICOL;
            stack->slot_0_has_current_sym_data_ = 1;
            break;
            case 4: /* \, */
            stack->current_sym_ = CARB_COMMA;
            stack->slot_0_has_current_sym_data_ = 1;
            break;
            case 5: /* \+ */
            stack->current_sym_ = CARB_PLUS;
            stack->slot_0_has_current_sym_data_ = 1;
            break;
            case 6: /* \- */
            stack->current_sym_ = CARB_MINUS;
            stack->slot_0_has_current_sym_data_ = 1;
            break;
            case 7: /* \* */
            stack->current_sym_ = CARB_ASTERISK;
            stack->slot_0_has_current_sym_data_ = 1;
            break;
            case 8: /* / */
            stack->current_sym_ = CARB_SLASH;
            stack->slot_0_has_current_sym_data_ = 1;
            break;
            case 9: /* % */
            stack->current_sym_ = CARB_PERCENT;
            stack->slot_0_has_current_sym_data_ = 1;
            break;
            case 10: /* \+\+ */
            stack->current_sym_ = CARB_INC;
            stack->slot_0_has_current_sym_data_ = 1;
            break;
            case 11: /* \-\- */
            stack->current_sym_ = CARB_DEC;
            stack->slot_0_has_current_sym_data_ = 1;
            break;
            case 12: /* & */
            stack->current_sym_ = CARB_AND;
            stack->slot_0_has_current_sym_data_ = 1;
            break;
            case 13: /* | */
            stack->current_sym_ = CARB_OR;
            stack->slot_0_has_current_sym_data_ = 1;
            break;
            case 14: /* ^ */
            stack->current_sym_ = CARB_XOR;
            stack->slot_0_has_current_sym_data_ = 1;
            break;
            case 15: /* ~ */
            stack->current_sym_ = CARB_COMP;
            stack->slot_0_has_current_sym_data_ = 1;
            break;
            case 16: /* >> */
            stack->current_sym_ = CARB_SHR;
            stack->slot_0_has_current_sym_data_ = 1;
            break;
            case 17: /* << */
            stack->current_sym_ = CARB_SHL;
            stack->slot_0_has_current_sym_data_ = 1;
            break;
            case 18: /* && */
            stack->current_sym_ = CARB_LAND;
            stack->slot_0_has_current_sym_data_ = 1;
            break;
            case 19: /* || */
            stack->current_sym_ = CARB_LOR;
            stack->slot_0_has_current_sym_data_ = 1;
            break;
            case 20: /* ! */
            stack->current_sym_ = CARB_DENY;
            stack->slot_0_has_current_sym_data_ = 1;
            break;
            case 21: /* == */
            stack->current_sym_ = CARB_EQUAL;
            stack->slot_0_has_current_sym_data_ = 1;
            break;
            case 22: /* != */
            stack->current_sym_ = CARB_NEQUAL;
            stack->slot_0_has_current_sym_data_ = 1;
            break;
            case 23: /* > */
            stack->current_sym_ = CARB_GREATER;
            stack->slot_0_has_current_sym_data_ = 1;
            break;
            case 24: /* < */
            stack->current_sym_ = CARB_LESSER;
            stack->slot_0_has_current_sym_data_ = 1;
            break;
            case 25: /* >= */
            stack->current_sym_ = CARB_GREATEQ;
            stack->slot_0_has_current_sym_data_ = 1;
            break;
            case 26: /* <= */
            stack->current_sym_ = CARB_LESSEQ;
            stack->slot_0_has_current_sym_data_ = 1;
            break;
            case 27: /* \( */
            stack->current_sym_ = CARB_LPAREN;
            stack->slot_0_has_current_sym_data_ = 1;
            break;
            case 28: /* \) */
            stack->current_sym_ = CARB_RPAREN;
            stack->slot_0_has_current_sym_data_ = 1;
            break;
            case 29: /* \{ */
            stack->current_sym_ = CARB_LCURLY;
            stack->slot_0_has_current_sym_data_ = 1;
            break;
            case 30: /* \} */
            stack->current_sym_ = CARB_RCURLY;
            stack->slot_0_has_current_sym_data_ = 1;
            break;
            case 31: /* [0-9]+ */
            stack->current_sym_ = CARB_DECIMAL;
            stack->slot_0_has_current_sym_data_ = 1;
            if (!stack->discard_remaining_actions_) {
              stack->continue_at_ = 1;
              {
                 (stack->stack_[0].v_.uv0_) = std::atoi((stack->match_buffer_)); 
              }
              C1:;
            }
            break;
            case 32: /* [a-zA-Z_][a-zA-Z0-9_]+ */
            stack->current_sym_ = CARB_ID;
            stack->slot_0_has_current_sym_data_ = 1;
            if (!stack->discard_remaining_actions_) {
              stack->continue_at_ = 2;
              {
                 (stack->stack_[0].v_.uv1_) = (stack->match_buffer_); 
              }
              C2:;
            }
            break;
            case 33: /* \".*\" */
            stack->current_sym_ = CARB_STRING;
            stack->slot_0_has_current_sym_data_ = 1;
            if (!stack->discard_remaining_actions_) {
              stack->continue_at_ = 3;
              {
                 (stack->stack_[0].v_.uv1_) = (stack->match_buffer_); 
              }
              C3:;
            }
            break;
            case 34: /* if */
            stack->current_sym_ = CARB_IF;
            stack->slot_0_has_current_sym_data_ = 1;
            break;
            case 35: /* else */
            stack->current_sym_ = CARB_ELSE;
            stack->slot_0_has_current_sym_data_ = 1;
            break;
            case 36: /* match */
            stack->current_sym_ = CARB_MATCH;
            stack->slot_0_has_current_sym_data_ = 1;
            break;
            case 37: /* for */
            stack->current_sym_ = CARB_FOR;
            stack->slot_0_has_current_sym_data_ = 1;
            break;
            case 38: /* loop */
            stack->current_sym_ = CARB_LOOP;
            stack->slot_0_has_current_sym_data_ = 1;
            break;
            case 39: /* while */
            stack->current_sym_ = CARB_WHILE;
            stack->slot_0_has_current_sym_data_ = 1;
            break;
            case 40: /* true */
            stack->current_sym_ = CARB_TRUE;
            stack->slot_0_has_current_sym_data_ = 1;
            break;
            case 41: /* false */
            stack->current_sym_ = CARB_FALSE;
            stack->slot_0_has_current_sym_data_ = 1;
            break;
            case 42: /* break */
            stack->current_sym_ = CARB_BREAK;
            stack->slot_0_has_current_sym_data_ = 1;
            break;
          } /* switch */
        } /* scope guard */
        break;
        case _CARB_OVERFLOW:
        stack->continue_at_ = 0;
        return _CARB_OVERFLOW;
        case _CARB_NO_MEMORY:
        stack->continue_at_ = 0;
        return _CARB_NO_MEMORY;
        case _CARB_FEED_ME:
        stack->continue_at_ = 0;
        /* Need more input */
        return _CARB_FEED_ME;
        case _CARB_END_OF_INPUT:
        stack->current_sym_ = CARB_INPUT_END;
        stack->need_sym_ = 0;
        if (stack->mute_error_turns_) stack->mute_error_turns_--;
        break;
        case _CARB_LEXICAL_ERROR:
        stack->continue_at_ = 0;
        /* Lexical error */
        return _CARB_LEXICAL_ERROR;
      } /* switch */
    } /* if (need_sym_) */
    else {
      int sym;
      sym = stack->current_sym_;
      if (!stack->error_recovery_) {
        int action;
        action = carb_parse_table[carb_num_columns * stack->stack_[stack->pos_ - 1].state_ + (sym - carb_minimum_sym)];
        if (action > 0) {
          if (stack->num_stack_allocated_ == stack->pos_) {
            size_t new_num_allocated;
            if (stack->num_stack_allocated_) {
              new_num_allocated = stack->num_stack_allocated_ * 2;
              if (new_num_allocated <= stack->num_stack_allocated_) {
                /* Overflow in allocation */
                return _CARB_OVERFLOW;
              }
            }
            else {
              new_num_allocated = 16;
            }
            
            if (new_num_allocated > (SIZE_MAX / sizeof(struct carb_sym_data))) {
              /* Overflow in allocation */
              return _CARB_OVERFLOW;
            }
            
            void *p = realloc(stack->stack_, new_num_allocated * sizeof(struct carb_sym_data));
            if (!p) {
              /* Out of memory */
              return _CARB_NO_MEMORY;
            }
            stack->num_stack_allocated_ = stack->new_buf_num_allocated_;
          }
          stack->stack_[stack->pos_++].state_ = action;
          stack->top_of_stack_has_sym_data_ = 0;
          stack->top_of_stack_has_common_data_ = 0;
          
          /* Fill in the sym from the tokenizer */
          stack->need_sym_ = 1;
          memcpy(&stack->stack_[stack->pos_ - 1].v_, &stack->stack_[0].v_, sizeof(stack->stack_[0].v_));
          stack->slot_0_has_current_sym_data_ = 0;
        } /* action > 0 */
        else if (action < 0) {
          int production;
          production = -action - 1;
          stack->discard_remaining_actions_ = 0;
          stack->current_production_length_ = carb_production_lengths[production];
          stack->current_production_nonterminal_ = carb_production_syms[production];
          if (0 == production) {
            stack->pending_reset_ = 1;
            return _CARB_FINISH;
          }
          
          memset(&stack->stack_[1], 0, sizeof(struct carb_sym_data));
          { /* scope guard */
            stack->sym_data_ = stack->stack_ + stack->pos_ - stack->current_production_length_;
            switch (production) {
              /* globals: global globals */
              case 1: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_GLOBALS;
                stack->continue_at_ = 4;
                {
                  {
		Unit u {std::move((stack->sym_data_[1].v_.uv3_))};
		u._defs.push_back((stack->sym_data_[0].v_.uv4_));
		(stack->stack_[1].v_.uv3_) = u;
	}
                }
                C4:;
              }
              break;
              /* globals: */
              case 2: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_GLOBALS;
                stack->continue_at_ = 5;
                {
                  { (stack->stack_[1].v_.uv3_) = Unit(); }
                }
                C5:;
              }
              break;
              /* global: function_def */
              case 3: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_GLOBAL;
                stack->continue_at_ = 6;
                {
                  { (stack->stack_[1].v_.uv4_) = (stack->sym_data_[0].v_.uv6_); }
                }
                C6:;
              }
              break;
              /* global: var_def_stmt */
              case 4: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_GLOBAL;
                stack->continue_at_ = 7;
                {
                  { (stack->stack_[1].v_.uv4_) = (stack->sym_data_[0].v_.uv13_); }
                }
                C7:;
              }
              break;
              /* type_expr: ID */
              case 5: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_TYPE_EXPR;
                stack->continue_at_ = 8;
                {
                  { (stack->stack_[1].v_.uv5_) = new TypeNode((stack->sym_data_[0].v_.uv1_)); }
                }
                C8:;
              }
              break;
              /* function_def: type_expr ID LPAREN param_list RPAREN compound_stmt */
              case 6: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_FUNCTION_DEF;
                stack->continue_at_ = 9;
                {
                  { (stack->stack_[1].v_.uv6_) = new FunctionNode((stack->sym_data_[0].v_.uv5_), (stack->sym_data_[1].v_.uv1_), std::move((stack->sym_data_[3].v_.uv7_)), std::move((stack->sym_data_[5].v_.uv11_)));}
                }
                C9:;
              }
              break;
              /* param_list: param param_list_tail */
              case 7: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_PARAM_LIST;
                stack->continue_at_ = 10;
                {
                  {
		FunctionNode::ParamList l {std::move((stack->sym_data_[1].v_.uv8_))};
		l.push_back((stack->sym_data_[0].v_.uv9_));
		(stack->stack_[1].v_.uv7_) = l;
	}
                }
                C10:;
              }
              break;
              /* param_list: */
              case 8: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_PARAM_LIST;
                stack->continue_at_ = 11;
                {
                  { (stack->stack_[1].v_.uv7_) = FunctionNode::ParamList(); }
                }
                C11:;
              }
              break;
              /* param_list_tail: COMMA param param_list_tail */
              case 9: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_PARAM_LIST_TAIL;
                stack->continue_at_ = 12;
                {
                  {
		FunctionNode::ParamList l {std::move((stack->sym_data_[2].v_.uv8_))};
		l.push_back((stack->sym_data_[1].v_.uv9_));
		(stack->stack_[1].v_.uv8_) = l;
	}
                }
                C12:;
              }
              break;
              /* param_list_tail: */
              case 10: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_PARAM_LIST_TAIL;
                stack->continue_at_ = 13;
                {
                  { (stack->stack_[1].v_.uv8_) = FunctionNode::ParamList(); }
                }
                C13:;
              }
              break;
              /* param: type_expr ID */
              case 11: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_PARAM;
                stack->continue_at_ = 14;
                {
                  { (stack->stack_[1].v_.uv9_) = std::pair((stack->sym_data_[0].v_.uv5_), std::move((stack->sym_data_[1].v_.uv1_))); }
                }
                C14:;
              }
              break;
              /* statement: compound_stmt */
              case 12: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_STATEMENT;
                stack->continue_at_ = 15;
                {
                  { (stack->stack_[1].v_.uv10_) = (stack->sym_data_[0].v_.uv11_); }
                }
                C15:;
              }
              break;
              /* statement: var_def_stmt */
              case 13: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_STATEMENT;
                stack->continue_at_ = 16;
                {
                  { (stack->stack_[1].v_.uv10_) = (stack->sym_data_[0].v_.uv13_); }
                }
                C16:;
              }
              break;
              /* statement: expression */
              case 14: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_STATEMENT;
                stack->continue_at_ = 17;
                {
                  { (stack->stack_[1].v_.uv10_) = (stack->sym_data_[0].v_.uv14_); }
                }
                C17:;
              }
              break;
              /* statement: expression_stmt */
              case 15: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_STATEMENT;
                stack->continue_at_ = 18;
                {
                  { (stack->stack_[1].v_.uv10_) = (stack->sym_data_[0].v_.uv15_); }
                }
                C18:;
              }
              break;
              /* statement: break_stmt */
              case 16: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_STATEMENT;
                stack->continue_at_ = 19;
                {
                  { (stack->stack_[1].v_.uv10_) = (stack->sym_data_[0].v_.uv21_); }
                }
                C19:;
              }
              break;
              /* compound_stmt: LCURLY statements RCURLY */
              case 17: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_COMPOUND_STMT;
                stack->continue_at_ = 20;
                {
                  { (stack->stack_[1].v_.uv11_) = new CompoundStmtNode(std::move((stack->sym_data_[1].v_.uv12_))); }
                }
                C20:;
              }
              break;
              /* statements: statement statements */
              case 18: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_STATEMENTS;
                stack->continue_at_ = 21;
                {
                  {
		CompoundStmtNode::StmtList l {std::move((stack->sym_data_[1].v_.uv12_))};
		l.push_back((stack->sym_data_[0].v_.uv10_));
		(stack->stack_[1].v_.uv12_) = l;
	}
                }
                C21:;
              }
              break;
              /* statements: */
              case 19: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_STATEMENTS;
                stack->continue_at_ = 22;
                {
                  { (stack->stack_[1].v_.uv12_) = CompoundStmtNode::StmtList(); }
                }
                C22:;
              }
              break;
              /* var_def_stmt: type_expr ID ASSIGN expression SEMICOL */
              case 20: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_VAR_DEF_STMT;
                stack->continue_at_ = 23;
                {
                  { (stack->stack_[1].v_.uv13_) = new VarDefStmtNode((stack->sym_data_[0].v_.uv5_), (stack->sym_data_[1].v_.uv1_), (stack->sym_data_[3].v_.uv14_)); }
                }
                C23:;
              }
              break;
              /* expression: assignment_expr */
              case 21: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_EXPRESSION;
                stack->continue_at_ = 24;
                {
                  { (stack->stack_[1].v_.uv14_) = (stack->sym_data_[0].v_.uv16_); }
                }
                C24:;
              }
              break;
              /* expression: if_expr */
              case 22: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_EXPRESSION;
                stack->continue_at_ = 25;
                {
                  { (stack->stack_[1].v_.uv14_) = (stack->sym_data_[0].v_.uv17_); }
                }
                C25:;
              }
              break;
              /* expression: for_expr */
              case 23: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_EXPRESSION;
                stack->continue_at_ = 26;
                {
                  { (stack->stack_[1].v_.uv14_) = (stack->sym_data_[0].v_.uv18_); }
                }
                C26:;
              }
              break;
              /* expression: loop_expr */
              case 24: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_EXPRESSION;
                stack->continue_at_ = 27;
                {
                  { (stack->stack_[1].v_.uv14_) = (stack->sym_data_[0].v_.uv19_); }
                }
                C27:;
              }
              break;
              /* expression: while_expr */
              case 25: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_EXPRESSION;
                stack->continue_at_ = 28;
                {
                  { (stack->stack_[1].v_.uv14_) = (stack->sym_data_[0].v_.uv20_); }
                }
                C28:;
              }
              break;
              /* expression: logic_or_expr */
              case 26: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_EXPRESSION;
                stack->continue_at_ = 29;
                {
                  { (stack->stack_[1].v_.uv14_) = (stack->sym_data_[0].v_.uv36_); }
                }
                C29:;
              }
              break;
              /* expression_stmt: expression SEMICOL */
              case 27: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_EXPRESSION_STMT;
                stack->continue_at_ = 30;
                {
                  { (stack->stack_[1].v_.uv15_) = new ExprStmtNode((stack->sym_data_[0].v_.uv14_)); }
                }
                C30:;
              }
              break;
              /* assignment_expr: ID ASSIGN expression */
              case 28: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_ASSIGNMENT_EXPR;
                stack->continue_at_ = 31;
                {
                  {(stack->stack_[1].v_.uv16_) = new AssignExprNode(std::move((stack->sym_data_[0].v_.uv1_)), (stack->sym_data_[2].v_.uv14_)); }
                }
                C31:;
              }
              break;
              /* if_expr: IF LPAREN expression RPAREN statement */
              case 29: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_IF_EXPR;
                stack->continue_at_ = 32;
                {
                  { (stack->stack_[1].v_.uv17_) = new IfExprNode((stack->sym_data_[2].v_.uv14_), (stack->sym_data_[4].v_.uv10_), nullptr); }
                }
                C32:;
              }
              break;
              /* if_expr: IF LPAREN expression RPAREN statement ELSE statement */
              case 30: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_IF_EXPR;
                stack->continue_at_ = 33;
                {
                  { (stack->stack_[1].v_.uv17_) = new IfExprNode((stack->sym_data_[2].v_.uv14_), (stack->sym_data_[4].v_.uv10_), (stack->sym_data_[6].v_.uv10_)); }
                }
                C33:;
              }
              break;
              /* for_expr: FOR LPAREN expr_maybe SEMICOL expr_maybe SEMICOL expr_maybe RPAREN statement */
              case 31: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_FOR_EXPR;
                stack->continue_at_ = 34;
                {
                  { (stack->stack_[1].v_.uv18_) = new ForExprNode((stack->sym_data_[2].v_.uv22_), (stack->sym_data_[4].v_.uv22_), (stack->sym_data_[6].v_.uv22_), (stack->sym_data_[8].v_.uv10_)); }
                }
                C34:;
              }
              break;
              /* loop_expr: LOOP statement */
              case 32: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_LOOP_EXPR;
                stack->continue_at_ = 35;
                {
                  { (stack->stack_[1].v_.uv19_) = new LoopExprNode((stack->sym_data_[1].v_.uv10_)); }
                }
                C35:;
              }
              break;
              /* while_expr: WHILE LPAREN expression RPAREN statement */
              case 33: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_WHILE_EXPR;
                stack->continue_at_ = 36;
                {
                  { (stack->stack_[1].v_.uv20_) = new WhileExprNode((stack->sym_data_[2].v_.uv14_), (stack->sym_data_[4].v_.uv10_)); }
                }
                C36:;
              }
              break;
              /* break_stmt: BREAK expr_maybe SEMICOL */
              case 34: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_BREAK_STMT;
                stack->continue_at_ = 37;
                {
                  { (stack->stack_[1].v_.uv21_) = new BreakStmtNode((stack->sym_data_[1].v_.uv22_)); }
                }
                C37:;
              }
              break;
              /* break_stmt: BREAK LPAREN DECIMAL RPAREN expr_maybe SEMICOL */
              case 35: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_BREAK_STMT;
                stack->continue_at_ = 38;
                {
                  { (stack->stack_[1].v_.uv21_) = new BreakStmtNode((stack->sym_data_[4].v_.uv22_), (stack->sym_data_[2].v_.uv0_)); }
                }
                C38:;
              }
              break;
              /* expr_maybe: expression */
              case 36: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_EXPR_MAYBE;
                stack->continue_at_ = 39;
                {
                  { (stack->stack_[1].v_.uv22_) = (stack->sym_data_[0].v_.uv14_); }
                }
                C39:;
              }
              break;
              /* expr_maybe: */
              case 37: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_EXPR_MAYBE;
                stack->continue_at_ = 40;
                {
                  { (stack->stack_[1].v_.uv22_) = nullptr; }
                }
                C40:;
              }
              break;
              /* primary_expr: LPAREN expression RPAREN */
              case 38: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_PRIMARY_EXPR;
                stack->continue_at_ = 41;
                {
                  { (stack->stack_[1].v_.uv23_) = (stack->sym_data_[1].v_.uv14_); }
                }
                C41:;
              }
              break;
              /* primary_expr: ID LPAREN arg_list RPAREN */
              case 39: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_PRIMARY_EXPR;
                stack->continue_at_ = 42;
                {
                  { (stack->stack_[1].v_.uv23_) = new InvokeNode((stack->sym_data_[0].v_.uv1_), (stack->sym_data_[2].v_.uv24_)); }
                }
                C42:;
              }
              break;
              /* primary_expr: literal */
              case 40: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_PRIMARY_EXPR;
                stack->continue_at_ = 43;
                {
                  { (stack->stack_[1].v_.uv23_) = (stack->sym_data_[0].v_.uv37_); }
                }
                C43:;
              }
              break;
              /* arg_list: expression arg_list_tail */
              case 41: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_ARG_LIST;
                stack->continue_at_ = 44;
                {
                  {
		InvokeNode::ArgList l {std::move((stack->sym_data_[1].v_.uv25_))};
		l.push_back((stack->sym_data_[0].v_.uv14_));
		(stack->stack_[1].v_.uv24_) = l;
	}
                }
                C44:;
              }
              break;
              /* arg_list: */
              case 42: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_ARG_LIST;
                stack->continue_at_ = 45;
                {
                  { (stack->stack_[1].v_.uv24_) = InvokeNode::ArgList(); }
                }
                C45:;
              }
              break;
              /* arg_list_tail: COMMA expression arg_list_tail */
              case 43: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_ARG_LIST_TAIL;
                stack->continue_at_ = 46;
                {
                  {
		InvokeNode::ArgList l {std::move((stack->sym_data_[2].v_.uv25_))};
		l.push_back((stack->sym_data_[1].v_.uv14_));
		(stack->stack_[1].v_.uv25_) = l;
	}
                }
                C46:;
              }
              break;
              /* arg_list_tail: */
              case 44: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_ARG_LIST_TAIL;
                stack->continue_at_ = 47;
                {
                  { (stack->stack_[1].v_.uv25_) = InvokeNode::ArgList(); }
                }
                C47:;
              }
              break;
              /* pre_expr: primary_expr */
              case 45: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_PRE_EXPR;
                stack->continue_at_ = 48;
                {
                  { (stack->stack_[1].v_.uv26_) = (stack->sym_data_[0].v_.uv23_); }
                }
                C48:;
              }
              break;
              /* pre_expr: PLUS primary_expr */
              case 46: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_PRE_EXPR;
                stack->continue_at_ = 49;
                {
                  { (stack->stack_[1].v_.uv26_) = new PreExprNode((stack->sym_data_[1].v_.uv23_), PreExprNode::Ops::Pos); }
                }
                C49:;
              }
              break;
              /* pre_expr: MINUS primary_expr */
              case 47: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_PRE_EXPR;
                stack->continue_at_ = 50;
                {
                  { (stack->stack_[1].v_.uv26_) = new PreExprNode((stack->sym_data_[1].v_.uv23_), PreExprNode::Ops::Neg); }
                }
                C50:;
              }
              break;
              /* pre_expr: INC primary_expr */
              case 48: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_PRE_EXPR;
                stack->continue_at_ = 51;
                {
                  { (stack->stack_[1].v_.uv26_) = new PreExprNode((stack->sym_data_[1].v_.uv23_), PreExprNode::Ops::Inc); }
                }
                C51:;
              }
              break;
              /* pre_expr: DEC primary_expr */
              case 49: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_PRE_EXPR;
                stack->continue_at_ = 52;
                {
                  { (stack->stack_[1].v_.uv26_) = new PreExprNode((stack->sym_data_[1].v_.uv23_), PreExprNode::Ops::Dec); }
                }
                C52:;
              }
              break;
              /* pre_expr: DENY primary_expr */
              case 50: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_PRE_EXPR;
                stack->continue_at_ = 53;
                {
                  { (stack->stack_[1].v_.uv26_) = new PreExprNode((stack->sym_data_[1].v_.uv23_), PreExprNode::Ops::Deny); }
                }
                C53:;
              }
              break;
              /* pre_expr: COMP primary_expr */
              case 51: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_PRE_EXPR;
                stack->continue_at_ = 54;
                {
                  { (stack->stack_[1].v_.uv26_) = new PreExprNode((stack->sym_data_[1].v_.uv23_), PreExprNode::Ops::Comp); }
                }
                C54:;
              }
              break;
              /* multiplicative_expr: pre_expr */
              case 52: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_MULTIPLICATIVE_EXPR;
                stack->continue_at_ = 55;
                {
                  { (stack->stack_[1].v_.uv27_) = (stack->sym_data_[0].v_.uv26_); }
                }
                C55:;
              }
              break;
              /* multiplicative_expr: multiplicative_expr ASTERISK pre_expr */
              case 53: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_MULTIPLICATIVE_EXPR;
                stack->continue_at_ = 56;
                {
                  { (stack->stack_[1].v_.uv27_) = new BinaryExprNode((stack->sym_data_[0].v_.uv27_), (stack->sym_data_[1].v_.uv2_), BinaryExprNode::Ops::Mul); }
                }
                C56:;
              }
              break;
              /* multiplicative_expr: multiplicative_expr SLASH pre_expr */
              case 54: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_MULTIPLICATIVE_EXPR;
                stack->continue_at_ = 57;
                {
                  { (stack->stack_[1].v_.uv27_) = new BinaryExprNode((stack->sym_data_[0].v_.uv27_), (stack->sym_data_[1].v_.uv2_), BinaryExprNode::Ops::Div); }
                }
                C57:;
              }
              break;
              /* multiplicative_expr: multiplicative_expr PERCENT pre_expr */
              case 55: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_MULTIPLICATIVE_EXPR;
                stack->continue_at_ = 58;
                {
                  { (stack->stack_[1].v_.uv27_) = new BinaryExprNode((stack->sym_data_[0].v_.uv27_), (stack->sym_data_[1].v_.uv2_), BinaryExprNode::Ops::Mod); }
                }
                C58:;
              }
              break;
              /* additive_expr: multiplicative_expr */
              case 56: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_ADDITIVE_EXPR;
                stack->continue_at_ = 59;
                {
                  { (stack->stack_[1].v_.uv28_) = (stack->sym_data_[0].v_.uv27_); }
                }
                C59:;
              }
              break;
              /* additive_expr: additive_expr PLUS multiplicative_expr */
              case 57: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_ADDITIVE_EXPR;
                stack->continue_at_ = 60;
                {
                  { (stack->stack_[1].v_.uv28_) = new BinaryExprNode((stack->sym_data_[0].v_.uv28_), (stack->sym_data_[1].v_.uv2_), BinaryExprNode::Ops::Add); }
                }
                C60:;
              }
              break;
              /* additive_expr: additive_expr MINUS multiplicative_expr */
              case 58: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_ADDITIVE_EXPR;
                stack->continue_at_ = 61;
                {
                  { (stack->stack_[1].v_.uv28_) = new BinaryExprNode((stack->sym_data_[0].v_.uv28_), (stack->sym_data_[1].v_.uv2_), BinaryExprNode::Ops::Sub); }
                }
                C61:;
              }
              break;
              /* shift_expr: additive_expr */
              case 59: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_SHIFT_EXPR;
                stack->continue_at_ = 62;
                {
                  { (stack->stack_[1].v_.uv29_) = (stack->sym_data_[0].v_.uv28_); }
                }
                C62:;
              }
              break;
              /* shift_expr: shift_expr SHL additive_expr */
              case 60: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_SHIFT_EXPR;
                stack->continue_at_ = 63;
                {
                  { (stack->stack_[1].v_.uv29_) = new BinaryExprNode((stack->sym_data_[0].v_.uv29_), (stack->sym_data_[1].v_.uv2_), BinaryExprNode::Ops::LShift); }
                }
                C63:;
              }
              break;
              /* shift_expr: shift_expr SHR additive_expr */
              case 61: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_SHIFT_EXPR;
                stack->continue_at_ = 64;
                {
                  { (stack->stack_[1].v_.uv29_) = new BinaryExprNode((stack->sym_data_[0].v_.uv29_), (stack->sym_data_[1].v_.uv2_), BinaryExprNode::Ops::RShift); }
                }
                C64:;
              }
              break;
              /* relative_expr: shift_expr */
              case 62: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_RELATIVE_EXPR;
                stack->continue_at_ = 65;
                {
                  { (stack->stack_[1].v_.uv30_) = (stack->sym_data_[0].v_.uv29_); }
                }
                C65:;
              }
              break;
              /* relative_expr: relative_expr LESSER shift_expr */
              case 63: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_RELATIVE_EXPR;
                stack->continue_at_ = 66;
                {
                  { (stack->stack_[1].v_.uv30_) = new BinaryExprNode((stack->sym_data_[0].v_.uv30_), (stack->sym_data_[1].v_.uv2_), BinaryExprNode::Ops::Less); }
                }
                C66:;
              }
              break;
              /* relative_expr: relative_expr LESSEQ shift_expr */
              case 64: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_RELATIVE_EXPR;
                stack->continue_at_ = 67;
                {
                  { (stack->stack_[1].v_.uv30_) = new BinaryExprNode((stack->sym_data_[0].v_.uv30_), (stack->sym_data_[1].v_.uv2_), BinaryExprNode::Ops::LessEq); }
                }
                C67:;
              }
              break;
              /* relative_expr: relative_expr GREATER shift_expr */
              case 65: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_RELATIVE_EXPR;
                stack->continue_at_ = 68;
                {
                  { (stack->stack_[1].v_.uv30_) = new BinaryExprNode((stack->sym_data_[0].v_.uv30_), (stack->sym_data_[1].v_.uv2_), BinaryExprNode::Ops::More); }
                }
                C68:;
              }
              break;
              /* relative_expr: relative_expr GREATEQ shift_expr */
              case 66: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_RELATIVE_EXPR;
                stack->continue_at_ = 69;
                {
                  { (stack->stack_[1].v_.uv30_) = new BinaryExprNode((stack->sym_data_[0].v_.uv30_), (stack->sym_data_[1].v_.uv2_), BinaryExprNode::Ops::MoreEq); }
                }
                C69:;
              }
              break;
              /* absolute_expr: relative_expr */
              case 67: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_ABSOLUTE_EXPR;
                stack->continue_at_ = 70;
                {
                  { (stack->stack_[1].v_.uv31_) = (stack->sym_data_[0].v_.uv30_); }
                }
                C70:;
              }
              break;
              /* absolute_expr: absolute_expr EQUAL relative_expr */
              case 68: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_ABSOLUTE_EXPR;
                stack->continue_at_ = 71;
                {
                  { (stack->stack_[1].v_.uv31_) = new BinaryExprNode((stack->sym_data_[0].v_.uv31_), (stack->sym_data_[1].v_.uv2_), BinaryExprNode::Ops::EQ); }
                }
                C71:;
              }
              break;
              /* absolute_expr: absolute_expr NEQUAL relative_expr */
              case 69: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_ABSOLUTE_EXPR;
                stack->continue_at_ = 72;
                {
                  { (stack->stack_[1].v_.uv31_) = new BinaryExprNode((stack->sym_data_[0].v_.uv31_), (stack->sym_data_[1].v_.uv2_), BinaryExprNode::Ops::NEQ); }
                }
                C72:;
              }
              break;
              /* bit_and_expr: absolute_expr */
              case 70: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_BIT_AND_EXPR;
                stack->continue_at_ = 73;
                {
                  { (stack->stack_[1].v_.uv32_) = (stack->sym_data_[0].v_.uv31_); }
                }
                C73:;
              }
              break;
              /* bit_and_expr: bit_and_expr AND absolute_expr */
              case 71: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_BIT_AND_EXPR;
                stack->continue_at_ = 74;
                {
                  { (stack->stack_[1].v_.uv32_) = new BinaryExprNode((stack->sym_data_[0].v_.uv32_), (stack->sym_data_[1].v_.uv2_), BinaryExprNode::Ops::AND); }
                }
                C74:;
              }
              break;
              /* bit_xor_expr: bit_and_expr */
              case 72: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_BIT_XOR_EXPR;
                stack->continue_at_ = 75;
                {
                  { (stack->stack_[1].v_.uv33_) = (stack->sym_data_[0].v_.uv32_); }
                }
                C75:;
              }
              break;
              /* bit_xor_expr: bit_xor_expr XOR bit_and_expr */
              case 73: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_BIT_XOR_EXPR;
                stack->continue_at_ = 76;
                {
                  { (stack->stack_[1].v_.uv33_) = new BinaryExprNode((stack->sym_data_[0].v_.uv33_), (stack->sym_data_[1].v_.uv2_), BinaryExprNode::Ops::XOR); }
                }
                C76:;
              }
              break;
              /* bit_or_expr: bit_xor_expr */
              case 74: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_BIT_OR_EXPR;
                stack->continue_at_ = 77;
                {
                  { (stack->stack_[1].v_.uv34_) = (stack->sym_data_[0].v_.uv33_); }
                }
                C77:;
              }
              break;
              /* bit_or_expr: bit_or_expr OR bit_xor_expr */
              case 75: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_BIT_OR_EXPR;
                stack->continue_at_ = 78;
                {
                  { (stack->stack_[1].v_.uv34_) = new BinaryExprNode((stack->sym_data_[0].v_.uv34_), (stack->sym_data_[1].v_.uv2_), BinaryExprNode::Ops::OR); }
                }
                C78:;
              }
              break;
              /* logic_and_expr: bit_or_expr */
              case 76: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_LOGIC_AND_EXPR;
                stack->continue_at_ = 79;
                {
                  { (stack->stack_[1].v_.uv35_) = (stack->sym_data_[0].v_.uv34_); }
                }
                C79:;
              }
              break;
              /* logic_and_expr: logic_and_expr LAND bit_or_expr */
              case 77: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_LOGIC_AND_EXPR;
                stack->continue_at_ = 80;
                {
                  { (stack->stack_[1].v_.uv35_) = new BinaryExprNode((stack->sym_data_[0].v_.uv35_), (stack->sym_data_[1].v_.uv2_), BinaryExprNode::Ops::LAND); }
                }
                C80:;
              }
              break;
              /* logic_or_expr: logic_and_expr */
              case 78: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_LOGIC_OR_EXPR;
                stack->continue_at_ = 81;
                {
                  { (stack->stack_[1].v_.uv36_) = (stack->sym_data_[0].v_.uv35_); }
                }
                C81:;
              }
              break;
              /* logic_or_expr: logic_or_expr LOR logic_and_expr */
              case 79: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_LOGIC_OR_EXPR;
                stack->continue_at_ = 82;
                {
                  { (stack->stack_[1].v_.uv36_) = new BinaryExprNode((stack->sym_data_[0].v_.uv36_), (stack->sym_data_[1].v_.uv2_), BinaryExprNode::Ops::LOR); }
                }
                C82:;
              }
              break;
              /* literal: ID */
              case 80: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_LITERAL;
                stack->continue_at_ = 83;
                {
                  { (stack->stack_[1].v_.uv37_) = new IDNode(std::move((stack->sym_data_[0].v_.uv1_))); }
                }
                C83:;
              }
              break;
              /* literal: DECIMAL */
              case 81: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_LITERAL;
                stack->continue_at_ = 84;
                {
                  { (stack->stack_[1].v_.uv37_) = new DecimalNode((stack->sym_data_[0].v_.uv0_)); }
                }
                C84:;
              }
              break;
              /* literal: boolean */
              case 82: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_LITERAL;
                stack->continue_at_ = 85;
                {
                  { (stack->stack_[1].v_.uv37_) = new BoolNode((stack->sym_data_[0].v_.uv38_)); }
                }
                C85:;
              }
              break;
              /* literal: STRING */
              case 83: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_LITERAL;
                stack->continue_at_ = 86;
                {
                  { (stack->stack_[1].v_.uv37_) = StrNode::build(std::move((stack->sym_data_[0].v_.uv1_))); }
                }
                C86:;
              }
              break;
              /* boolean: TRUE */
              case 84: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_BOOLEAN;
                stack->continue_at_ = 87;
                {
                  { (stack->stack_[1].v_.uv38_) = true; }
                }
                C87:;
              }
              break;
              /* boolean: FALSE */
              case 85: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = CARB_BOOLEAN;
                stack->continue_at_ = 88;
                {
                  { (stack->stack_[1].v_.uv38_) = false; }
                }
                C88:;
              }
              break;
            } /* switch */
          } /* scope guard */
          
          stack->pos_ -= stack->current_production_length_;
          stack->top_of_stack_has_sym_data_ = stack->top_of_stack_has_common_data_ = 1;
          action = carb_parse_table[carb_num_columns * stack->stack_[stack->pos_ - 1].state_ + (stack->current_production_nonterminal_ - carb_minimum_sym)];
          if (action <= 0) {
            stack->continue_at_ = 0;
            /* Internal error */
            return _CARB_INTERNAL_ERROR;
          }
          if (stack->num_stack_allocated_ == stack->pos_) {
            size_t new_num_allocated;
            if (stack->num_stack_allocated_) {
              new_num_allocated = stack->num_stack_allocated_ * 2;
              if (new_num_allocated <= stack->num_stack_allocated_) {
                /* Overflow in allocation */
                return _CARB_OVERFLOW;
              }
            }
            else {
              new_num_allocated = 16;
            }
            
            if (new_num_allocated > (SIZE_MAX / sizeof(struct carb_sym_data))) {
              /* Overflow in allocation */
              return _CARB_OVERFLOW;
            }
            
            void *p = realloc(stack->stack_, new_num_allocated * sizeof(struct carb_sym_data));
            if (!p) {
              /* Out of memory */
              return _CARB_NO_MEMORY;
            }
            stack->num_stack_allocated_ = stack->new_buf_num_allocated_;
          }
          stack->stack_[stack->pos_++].state_ = action /* action for a "goto" shift is the ordinal */;
          stack->top_of_stack_has_sym_data_ = 0;
          stack->top_of_stack_has_common_data_ = 0;
          memcpy(&stack->stack_[stack->pos_ - 1].v_, &stack->stack_[1].v_, sizeof(stack->stack_->v_));
          stack->slot_1_has_sym_data_ = 0;
        } /* action < 0 */
        else /* action == 0 */ {
          /* check if we can recover using an error token. */
          size_t n;
          for (n = 0; n < stack->pos_; ++n) {
            int err_action;
            err_action = carb_parse_table[carb_num_columns * stack->stack_[n].state_ + (44 /* error token */ - carb_minimum_sym)];
            if (err_action > 0) {
              /* we can transition on the error token somewhere on the stack */
              break;
            }
          }
          if (n != stack->pos_) {
            /* Enter error-token recovery mode given that such a recovery is possible */
            stack->error_recovery_ = (n != stack->pos_);
          }
          else {
            if (sym != CARB_INPUT_END) {
              /* Retain EOF but discard any other sym so we make progress */
              stack->need_sym_ = 1;
              /* Deconstruct placeholder location for discarded symbol */
              switch (stack->current_sym_) {
                case 32:
                break;
                case 33:
                case 34:
                break;
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 35:
                case 36:
                case 37:
                case 38:
                case 39:
                case 40:
                case 41:
                case 42:
                case 43:
                break;
                case 46:
                break;
                case 47:
                break;
                case 48:
                break;
                case 49:
                break;
                case 50:
                break;
                case 51:
                break;
                case 52:
                break;
                case 53:
                break;
                case 54:
                break;
                case 55:
                break;
                case 56:
                break;
                case 57:
                break;
                case 58:
                break;
                case 59:
                break;
                case 60:
                break;
                case 61:
                break;
                case 62:
                break;
                case 63:
                break;
                case 64:
                break;
                case 65:
                break;
                case 66:
                break;
                case 67:
                break;
                case 68:
                break;
                case 69:
                break;
                case 70:
                break;
                case 71:
                break;
                case 72:
                break;
                case 73:
                break;
                case 74:
                break;
                case 75:
                break;
                case 76:
                break;
                case 77:
                break;
                case 78:
                break;
                case 79:
                break;
                case 80:
                break;
                case 81:
                break;
              } /* switch */
            }
          }
          /* Issue the error here */
          if (!stack->mute_error_turns_) {
            stack->mute_error_turns_ = 3;
            stack->continue_at_ = 0;
            /* Syntax error */
            return _CARB_SYNTAX_ERROR;
          }
          else {
            stack->mute_error_turns_--;
            if (sym == CARB_INPUT_END) {
              /* EOF means we cannot shift to recover, and errors are muted, so return completion */
              stack->pending_reset_ = 1;
              return _CARB_FINISH;
            }
          }
        }
      } /* !stack->error_recovery_ */
      if (stack->error_recovery_) {
        size_t n;
        n = stack->pos_;
        if (n) {
          do {
            --n;
            /* Can we shift an error token? */
            int err_action;
            err_action = carb_parse_table[carb_num_columns * stack->stack_[n].state_ + (44 /* error token */ - carb_minimum_sym)];
            if (err_action > 0) {
              /* Does the resulting state accept the current symbol? */
              int err_sym_action;
              err_sym_action = carb_parse_table[carb_num_columns * err_action + (sym - carb_minimum_sym)];
              if (err_sym_action) {
                /* Current symbol is accepted, recover error condition by shifting the error token and then process the symbol as usual */
                stack->pos_ = n + 1;
                stack->top_of_stack_has_sym_data_ = stack->top_of_stack_has_common_data_ = 1;
                if (stack->num_stack_allocated_ == stack->pos_) {
                  size_t new_num_allocated;
                  if (stack->num_stack_allocated_) {
                    new_num_allocated = stack->num_stack_allocated_ * 2;
                    if (new_num_allocated <= stack->num_stack_allocated_) {
                      /* Overflow in allocation */
                      return _CARB_OVERFLOW;
                    }
                  }
                  else {
                    new_num_allocated = 16;
                  }
                  
                  if (new_num_allocated > (SIZE_MAX / sizeof(struct carb_sym_data))) {
                    /* Overflow in allocation */
                    return _CARB_OVERFLOW;
                  }
                  
                  void *p = realloc(stack->stack_, new_num_allocated * sizeof(struct carb_sym_data));
                  if (!p) {
                    /* Out of memory */
                    return _CARB_NO_MEMORY;
                  }
                  stack->num_stack_allocated_ = stack->new_buf_num_allocated_;
                }
                stack->stack_[stack->pos_++].state_ = err_action;
                stack->top_of_stack_has_sym_data_ = 0;
                stack->top_of_stack_has_common_data_ = 0;
                stack->error_recovery_ = 0;
                /* Break out of do { .. } while loop, we've recovered */
                break;
              } /* if (err_sym_action) (if the current sym can continue after an error transition) */
            } /* if (err_action) (if the state at position 'n' can accept an error transition) */
          } while (n);
        }
        if (stack->error_recovery_) {
          /* Did not yet recover, discard current sym and get next */
          if (stack->current_sym_ == CARB_INPUT_END) {
            /* EOF means we cannot shift to recover, so return completion */
            stack->pending_reset_ = 1;
            return _CARB_FINISH;
          }
          stack->need_sym_ = 1;
          /* Deconstruct placeholder location for discarded symbol */
          switch (stack->current_sym_) {
            case 32:
            break;
            case 33:
            case 34:
            break;
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
            case 16:
            case 17:
            case 18:
            case 19:
            case 20:
            case 21:
            case 22:
            case 23:
            case 24:
            case 25:
            case 26:
            case 27:
            case 28:
            case 29:
            case 30:
            case 31:
            case 35:
            case 36:
            case 37:
            case 38:
            case 39:
            case 40:
            case 41:
            case 42:
            case 43:
            break;
            case 46:
            break;
            case 47:
            break;
            case 48:
            break;
            case 49:
            break;
            case 50:
            break;
            case 51:
            break;
            case 52:
            break;
            case 53:
            break;
            case 54:
            break;
            case 55:
            break;
            case 56:
            break;
            case 57:
            break;
            case 58:
            break;
            case 59:
            break;
            case 60:
            break;
            case 61:
            break;
            case 62:
            break;
            case 63:
            break;
            case 64:
            break;
            case 65:
            break;
            case 66:
            break;
            case 67:
            break;
            case 68:
            break;
            case 69:
            break;
            case 70:
            break;
            case 71:
            break;
            case 72:
            break;
            case 73:
            break;
            case 74:
            break;
            case 75:
            break;
            case 76:
            break;
            case 77:
            break;
            case 78:
            break;
            case 79:
            break;
            case 80:
            break;
            case 81:
            break;
          } /* switch */
        }
      } /* stack->error_recovery_ */
    }
  } /* for (;;) */
}

int carb_parse(struct carb_stack *stack, int sym) {
  if (stack->pending_reset_) {
    int r;
    r = carb_stack_reset(stack);
    if (r) return r;
  }
    switch (stack->continue_at_) {
    case 0: break; /* fall through to regular code path */
    case 1: goto C1;
    case 2: goto C2;
    case 3: goto C3;
    case 4: goto C4;
    case 5: goto C5;
    case 6: goto C6;
    case 7: goto C7;
    case 8: goto C8;
    case 9: goto C9;
    case 10: goto C10;
    case 11: goto C11;
    case 12: goto C12;
    case 13: goto C13;
    case 14: goto C14;
    case 15: goto C15;
    case 16: goto C16;
    case 17: goto C17;
    case 18: goto C18;
    case 19: goto C19;
    case 20: goto C20;
    case 21: goto C21;
    case 22: goto C22;
    case 23: goto C23;
    case 24: goto C24;
    case 25: goto C25;
    case 26: goto C26;
    case 27: goto C27;
    case 28: goto C28;
    case 29: goto C29;
    case 30: goto C30;
    case 31: goto C31;
    case 32: goto C32;
    case 33: goto C33;
    case 34: goto C34;
    case 35: goto C35;
    case 36: goto C36;
    case 37: goto C37;
    case 38: goto C38;
    case 39: goto C39;
    case 40: goto C40;
    case 41: goto C41;
    case 42: goto C42;
    case 43: goto C43;
    case 44: goto C44;
    case 45: goto C45;
    case 46: goto C46;
    case 47: goto C47;
    case 48: goto C48;
    case 49: goto C49;
    case 50: goto C50;
    case 51: goto C51;
    case 52: goto C52;
    case 53: goto C53;
    case 54: goto C54;
    case 55: goto C55;
    case 56: goto C56;
    case 57: goto C57;
    case 58: goto C58;
    case 59: goto C59;
    case 60: goto C60;
    case 61: goto C61;
    case 62: goto C62;
    case 63: goto C63;
    case 64: goto C64;
    case 65: goto C65;
    case 66: goto C66;
    case 67: goto C67;
    case 68: goto C68;
    case 69: goto C69;
    case 70: goto C70;
    case 71: goto C71;
    case 72: goto C72;
    case 73: goto C73;
    case 74: goto C74;
    case 75: goto C75;
    case 76: goto C76;
    case 77: goto C77;
    case 78: goto C78;
    case 79: goto C79;
    case 80: goto C80;
    case 81: goto C81;
    case 82: goto C82;
    case 83: goto C83;
    case 84: goto C84;
    case 85: goto C85;
  } /* continuation switch */
if (stack->mute_error_turns_) stack->mute_error_turns_--;
  for (;;) {
    if (!stack->error_recovery_) {
      int action;
      action = carb_parse_table[carb_num_columns * stack->stack_[stack->pos_ - 1].state_ + (sym - carb_minimum_sym)];
      if (action > 0) {
        if (stack->num_stack_allocated_ == stack->pos_) {
          size_t new_num_allocated;
          if (stack->num_stack_allocated_) {
            new_num_allocated = stack->num_stack_allocated_ * 2;
            if (new_num_allocated <= stack->num_stack_allocated_) {
              /* Overflow in allocation */
              return _CARB_OVERFLOW;
            }
          }
          else {
            new_num_allocated = 16;
          }
          
          if (new_num_allocated > (SIZE_MAX / sizeof(struct carb_sym_data))) {
            /* Overflow in allocation */
            return _CARB_OVERFLOW;
          }
          
          void *p = realloc(stack->stack_, new_num_allocated * sizeof(struct carb_sym_data));
          if (!p) {
            /* Out of memory */
            return _CARB_NO_MEMORY;
          }
          stack->num_stack_allocated_ = stack->new_buf_num_allocated_;
        }
        stack->stack_[stack->pos_++].state_ = action;
        stack->top_of_stack_has_sym_data_ = 0;
        stack->top_of_stack_has_common_data_ = 0;
        
        stack->sym_data_ = stack->stack_ + stack->pos_ - 1;
        stack->top_of_stack_has_sym_data_ = 0;
        switch (sym) {
          case CARB_DECIMAL:
          stack->top_of_stack_has_sym_data_ = 1;
          break;
          case CARB_ID:
          case CARB_STRING:
          stack->top_of_stack_has_sym_data_ = 1;
          break;
          case CARB_ASSIGN:
          case CARB_SEMICOL:
          case CARB_COMMA:
          case CARB_PLUS:
          case CARB_MINUS:
          case CARB_ASTERISK:
          case CARB_SLASH:
          case CARB_PERCENT:
          case CARB_INC:
          case CARB_DEC:
          case CARB_AND:
          case CARB_OR:
          case CARB_XOR:
          case CARB_COMP:
          case CARB_SHR:
          case CARB_SHL:
          case CARB_LAND:
          case CARB_LOR:
          case CARB_DENY:
          case CARB_EQUAL:
          case CARB_NEQUAL:
          case CARB_GREATER:
          case CARB_LESSER:
          case CARB_GREATEQ:
          case CARB_LESSEQ:
          case CARB_LPAREN:
          case CARB_RPAREN:
          case CARB_LCURLY:
          case CARB_RCURLY:
          case CARB_IF:
          case CARB_ELSE:
          case CARB_MATCH:
          case CARB_FOR:
          case CARB_LOOP:
          case CARB_WHILE:
          case CARB_TRUE:
          case CARB_FALSE:
          case CARB_BREAK:
          stack->top_of_stack_has_sym_data_ = 1;
          break;
        } /* switch */
        stack->continue_at_ = 0;
        /* Next token */
        return _CARB_FEED_ME;
      } /* action > 0 */
      else if (action < 0) {
        int production;
        production = -action - 1;
        stack->discard_remaining_actions_ = 0;
        stack->current_production_length_ = carb_production_lengths[production];
        stack->current_production_nonterminal_ = carb_production_syms[production];
        if (0 == production) {
          stack->pending_reset_ = 1;
          /* Synth S we're done */
          return _CARB_FINISH;
        }
        
        memset(&stack->stack_[1], 0, sizeof(struct carb_sym_data));
        { /* scope guard */
          stack->sym_data_ = stack->stack_ + stack->pos_ - stack->current_production_length_;
          switch (production) {
            /* globals: global globals */
            case 1: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_GLOBALS;
              stack->continue_at_ = 1;
              {
                {
		Unit u {std::move((stack->sym_data_[1].v_.uv3_))};
		u._defs.push_back((stack->sym_data_[0].v_.uv4_));
		(stack->stack_[1].v_.uv3_) = u;
	}
              }
              C1:;
            }
            break;
            /* globals: */
            case 2: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_GLOBALS;
              stack->continue_at_ = 2;
              {
                { (stack->stack_[1].v_.uv3_) = Unit(); }
              }
              C2:;
            }
            break;
            /* global: function_def */
            case 3: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_GLOBAL;
              stack->continue_at_ = 3;
              {
                { (stack->stack_[1].v_.uv4_) = (stack->sym_data_[0].v_.uv6_); }
              }
              C3:;
            }
            break;
            /* global: var_def_stmt */
            case 4: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_GLOBAL;
              stack->continue_at_ = 4;
              {
                { (stack->stack_[1].v_.uv4_) = (stack->sym_data_[0].v_.uv13_); }
              }
              C4:;
            }
            break;
            /* type_expr: ID */
            case 5: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_TYPE_EXPR;
              stack->continue_at_ = 5;
              {
                { (stack->stack_[1].v_.uv5_) = new TypeNode((stack->sym_data_[0].v_.uv1_)); }
              }
              C5:;
            }
            break;
            /* function_def: type_expr ID LPAREN param_list RPAREN compound_stmt */
            case 6: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_FUNCTION_DEF;
              stack->continue_at_ = 6;
              {
                { (stack->stack_[1].v_.uv6_) = new FunctionNode((stack->sym_data_[0].v_.uv5_), (stack->sym_data_[1].v_.uv1_), std::move((stack->sym_data_[3].v_.uv7_)), std::move((stack->sym_data_[5].v_.uv11_)));}
              }
              C6:;
            }
            break;
            /* param_list: param param_list_tail */
            case 7: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_PARAM_LIST;
              stack->continue_at_ = 7;
              {
                {
		FunctionNode::ParamList l {std::move((stack->sym_data_[1].v_.uv8_))};
		l.push_back((stack->sym_data_[0].v_.uv9_));
		(stack->stack_[1].v_.uv7_) = l;
	}
              }
              C7:;
            }
            break;
            /* param_list: */
            case 8: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_PARAM_LIST;
              stack->continue_at_ = 8;
              {
                { (stack->stack_[1].v_.uv7_) = FunctionNode::ParamList(); }
              }
              C8:;
            }
            break;
            /* param_list_tail: COMMA param param_list_tail */
            case 9: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_PARAM_LIST_TAIL;
              stack->continue_at_ = 9;
              {
                {
		FunctionNode::ParamList l {std::move((stack->sym_data_[2].v_.uv8_))};
		l.push_back((stack->sym_data_[1].v_.uv9_));
		(stack->stack_[1].v_.uv8_) = l;
	}
              }
              C9:;
            }
            break;
            /* param_list_tail: */
            case 10: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_PARAM_LIST_TAIL;
              stack->continue_at_ = 10;
              {
                { (stack->stack_[1].v_.uv8_) = FunctionNode::ParamList(); }
              }
              C10:;
            }
            break;
            /* param: type_expr ID */
            case 11: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_PARAM;
              stack->continue_at_ = 11;
              {
                { (stack->stack_[1].v_.uv9_) = std::pair((stack->sym_data_[0].v_.uv5_), std::move((stack->sym_data_[1].v_.uv1_))); }
              }
              C11:;
            }
            break;
            /* statement: compound_stmt */
            case 12: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_STATEMENT;
              stack->continue_at_ = 12;
              {
                { (stack->stack_[1].v_.uv10_) = (stack->sym_data_[0].v_.uv11_); }
              }
              C12:;
            }
            break;
            /* statement: var_def_stmt */
            case 13: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_STATEMENT;
              stack->continue_at_ = 13;
              {
                { (stack->stack_[1].v_.uv10_) = (stack->sym_data_[0].v_.uv13_); }
              }
              C13:;
            }
            break;
            /* statement: expression */
            case 14: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_STATEMENT;
              stack->continue_at_ = 14;
              {
                { (stack->stack_[1].v_.uv10_) = (stack->sym_data_[0].v_.uv14_); }
              }
              C14:;
            }
            break;
            /* statement: expression_stmt */
            case 15: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_STATEMENT;
              stack->continue_at_ = 15;
              {
                { (stack->stack_[1].v_.uv10_) = (stack->sym_data_[0].v_.uv15_); }
              }
              C15:;
            }
            break;
            /* statement: break_stmt */
            case 16: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_STATEMENT;
              stack->continue_at_ = 16;
              {
                { (stack->stack_[1].v_.uv10_) = (stack->sym_data_[0].v_.uv21_); }
              }
              C16:;
            }
            break;
            /* compound_stmt: LCURLY statements RCURLY */
            case 17: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_COMPOUND_STMT;
              stack->continue_at_ = 17;
              {
                { (stack->stack_[1].v_.uv11_) = new CompoundStmtNode(std::move((stack->sym_data_[1].v_.uv12_))); }
              }
              C17:;
            }
            break;
            /* statements: statement statements */
            case 18: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_STATEMENTS;
              stack->continue_at_ = 18;
              {
                {
		CompoundStmtNode::StmtList l {std::move((stack->sym_data_[1].v_.uv12_))};
		l.push_back((stack->sym_data_[0].v_.uv10_));
		(stack->stack_[1].v_.uv12_) = l;
	}
              }
              C18:;
            }
            break;
            /* statements: */
            case 19: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_STATEMENTS;
              stack->continue_at_ = 19;
              {
                { (stack->stack_[1].v_.uv12_) = CompoundStmtNode::StmtList(); }
              }
              C19:;
            }
            break;
            /* var_def_stmt: type_expr ID ASSIGN expression SEMICOL */
            case 20: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_VAR_DEF_STMT;
              stack->continue_at_ = 20;
              {
                { (stack->stack_[1].v_.uv13_) = new VarDefStmtNode((stack->sym_data_[0].v_.uv5_), (stack->sym_data_[1].v_.uv1_), (stack->sym_data_[3].v_.uv14_)); }
              }
              C20:;
            }
            break;
            /* expression: assignment_expr */
            case 21: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_EXPRESSION;
              stack->continue_at_ = 21;
              {
                { (stack->stack_[1].v_.uv14_) = (stack->sym_data_[0].v_.uv16_); }
              }
              C21:;
            }
            break;
            /* expression: if_expr */
            case 22: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_EXPRESSION;
              stack->continue_at_ = 22;
              {
                { (stack->stack_[1].v_.uv14_) = (stack->sym_data_[0].v_.uv17_); }
              }
              C22:;
            }
            break;
            /* expression: for_expr */
            case 23: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_EXPRESSION;
              stack->continue_at_ = 23;
              {
                { (stack->stack_[1].v_.uv14_) = (stack->sym_data_[0].v_.uv18_); }
              }
              C23:;
            }
            break;
            /* expression: loop_expr */
            case 24: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_EXPRESSION;
              stack->continue_at_ = 24;
              {
                { (stack->stack_[1].v_.uv14_) = (stack->sym_data_[0].v_.uv19_); }
              }
              C24:;
            }
            break;
            /* expression: while_expr */
            case 25: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_EXPRESSION;
              stack->continue_at_ = 25;
              {
                { (stack->stack_[1].v_.uv14_) = (stack->sym_data_[0].v_.uv20_); }
              }
              C25:;
            }
            break;
            /* expression: logic_or_expr */
            case 26: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_EXPRESSION;
              stack->continue_at_ = 26;
              {
                { (stack->stack_[1].v_.uv14_) = (stack->sym_data_[0].v_.uv36_); }
              }
              C26:;
            }
            break;
            /* expression_stmt: expression SEMICOL */
            case 27: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_EXPRESSION_STMT;
              stack->continue_at_ = 27;
              {
                { (stack->stack_[1].v_.uv15_) = new ExprStmtNode((stack->sym_data_[0].v_.uv14_)); }
              }
              C27:;
            }
            break;
            /* assignment_expr: ID ASSIGN expression */
            case 28: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_ASSIGNMENT_EXPR;
              stack->continue_at_ = 28;
              {
                {(stack->stack_[1].v_.uv16_) = new AssignExprNode(std::move((stack->sym_data_[0].v_.uv1_)), (stack->sym_data_[2].v_.uv14_)); }
              }
              C28:;
            }
            break;
            /* if_expr: IF LPAREN expression RPAREN statement */
            case 29: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_IF_EXPR;
              stack->continue_at_ = 29;
              {
                { (stack->stack_[1].v_.uv17_) = new IfExprNode((stack->sym_data_[2].v_.uv14_), (stack->sym_data_[4].v_.uv10_), nullptr); }
              }
              C29:;
            }
            break;
            /* if_expr: IF LPAREN expression RPAREN statement ELSE statement */
            case 30: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_IF_EXPR;
              stack->continue_at_ = 30;
              {
                { (stack->stack_[1].v_.uv17_) = new IfExprNode((stack->sym_data_[2].v_.uv14_), (stack->sym_data_[4].v_.uv10_), (stack->sym_data_[6].v_.uv10_)); }
              }
              C30:;
            }
            break;
            /* for_expr: FOR LPAREN expr_maybe SEMICOL expr_maybe SEMICOL expr_maybe RPAREN statement */
            case 31: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_FOR_EXPR;
              stack->continue_at_ = 31;
              {
                { (stack->stack_[1].v_.uv18_) = new ForExprNode((stack->sym_data_[2].v_.uv22_), (stack->sym_data_[4].v_.uv22_), (stack->sym_data_[6].v_.uv22_), (stack->sym_data_[8].v_.uv10_)); }
              }
              C31:;
            }
            break;
            /* loop_expr: LOOP statement */
            case 32: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_LOOP_EXPR;
              stack->continue_at_ = 32;
              {
                { (stack->stack_[1].v_.uv19_) = new LoopExprNode((stack->sym_data_[1].v_.uv10_)); }
              }
              C32:;
            }
            break;
            /* while_expr: WHILE LPAREN expression RPAREN statement */
            case 33: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_WHILE_EXPR;
              stack->continue_at_ = 33;
              {
                { (stack->stack_[1].v_.uv20_) = new WhileExprNode((stack->sym_data_[2].v_.uv14_), (stack->sym_data_[4].v_.uv10_)); }
              }
              C33:;
            }
            break;
            /* break_stmt: BREAK expr_maybe SEMICOL */
            case 34: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_BREAK_STMT;
              stack->continue_at_ = 34;
              {
                { (stack->stack_[1].v_.uv21_) = new BreakStmtNode((stack->sym_data_[1].v_.uv22_)); }
              }
              C34:;
            }
            break;
            /* break_stmt: BREAK LPAREN DECIMAL RPAREN expr_maybe SEMICOL */
            case 35: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_BREAK_STMT;
              stack->continue_at_ = 35;
              {
                { (stack->stack_[1].v_.uv21_) = new BreakStmtNode((stack->sym_data_[4].v_.uv22_), (stack->sym_data_[2].v_.uv0_)); }
              }
              C35:;
            }
            break;
            /* expr_maybe: expression */
            case 36: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_EXPR_MAYBE;
              stack->continue_at_ = 36;
              {
                { (stack->stack_[1].v_.uv22_) = (stack->sym_data_[0].v_.uv14_); }
              }
              C36:;
            }
            break;
            /* expr_maybe: */
            case 37: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_EXPR_MAYBE;
              stack->continue_at_ = 37;
              {
                { (stack->stack_[1].v_.uv22_) = nullptr; }
              }
              C37:;
            }
            break;
            /* primary_expr: LPAREN expression RPAREN */
            case 38: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_PRIMARY_EXPR;
              stack->continue_at_ = 38;
              {
                { (stack->stack_[1].v_.uv23_) = (stack->sym_data_[1].v_.uv14_); }
              }
              C38:;
            }
            break;
            /* primary_expr: ID LPAREN arg_list RPAREN */
            case 39: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_PRIMARY_EXPR;
              stack->continue_at_ = 39;
              {
                { (stack->stack_[1].v_.uv23_) = new InvokeNode((stack->sym_data_[0].v_.uv1_), (stack->sym_data_[2].v_.uv24_)); }
              }
              C39:;
            }
            break;
            /* primary_expr: literal */
            case 40: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_PRIMARY_EXPR;
              stack->continue_at_ = 40;
              {
                { (stack->stack_[1].v_.uv23_) = (stack->sym_data_[0].v_.uv37_); }
              }
              C40:;
            }
            break;
            /* arg_list: expression arg_list_tail */
            case 41: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_ARG_LIST;
              stack->continue_at_ = 41;
              {
                {
		InvokeNode::ArgList l {std::move((stack->sym_data_[1].v_.uv25_))};
		l.push_back((stack->sym_data_[0].v_.uv14_));
		(stack->stack_[1].v_.uv24_) = l;
	}
              }
              C41:;
            }
            break;
            /* arg_list: */
            case 42: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_ARG_LIST;
              stack->continue_at_ = 42;
              {
                { (stack->stack_[1].v_.uv24_) = InvokeNode::ArgList(); }
              }
              C42:;
            }
            break;
            /* arg_list_tail: COMMA expression arg_list_tail */
            case 43: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_ARG_LIST_TAIL;
              stack->continue_at_ = 43;
              {
                {
		InvokeNode::ArgList l {std::move((stack->sym_data_[2].v_.uv25_))};
		l.push_back((stack->sym_data_[1].v_.uv14_));
		(stack->stack_[1].v_.uv25_) = l;
	}
              }
              C43:;
            }
            break;
            /* arg_list_tail: */
            case 44: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_ARG_LIST_TAIL;
              stack->continue_at_ = 44;
              {
                { (stack->stack_[1].v_.uv25_) = InvokeNode::ArgList(); }
              }
              C44:;
            }
            break;
            /* pre_expr: primary_expr */
            case 45: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_PRE_EXPR;
              stack->continue_at_ = 45;
              {
                { (stack->stack_[1].v_.uv26_) = (stack->sym_data_[0].v_.uv23_); }
              }
              C45:;
            }
            break;
            /* pre_expr: PLUS primary_expr */
            case 46: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_PRE_EXPR;
              stack->continue_at_ = 46;
              {
                { (stack->stack_[1].v_.uv26_) = new PreExprNode((stack->sym_data_[1].v_.uv23_), PreExprNode::Ops::Pos); }
              }
              C46:;
            }
            break;
            /* pre_expr: MINUS primary_expr */
            case 47: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_PRE_EXPR;
              stack->continue_at_ = 47;
              {
                { (stack->stack_[1].v_.uv26_) = new PreExprNode((stack->sym_data_[1].v_.uv23_), PreExprNode::Ops::Neg); }
              }
              C47:;
            }
            break;
            /* pre_expr: INC primary_expr */
            case 48: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_PRE_EXPR;
              stack->continue_at_ = 48;
              {
                { (stack->stack_[1].v_.uv26_) = new PreExprNode((stack->sym_data_[1].v_.uv23_), PreExprNode::Ops::Inc); }
              }
              C48:;
            }
            break;
            /* pre_expr: DEC primary_expr */
            case 49: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_PRE_EXPR;
              stack->continue_at_ = 49;
              {
                { (stack->stack_[1].v_.uv26_) = new PreExprNode((stack->sym_data_[1].v_.uv23_), PreExprNode::Ops::Dec); }
              }
              C49:;
            }
            break;
            /* pre_expr: DENY primary_expr */
            case 50: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_PRE_EXPR;
              stack->continue_at_ = 50;
              {
                { (stack->stack_[1].v_.uv26_) = new PreExprNode((stack->sym_data_[1].v_.uv23_), PreExprNode::Ops::Deny); }
              }
              C50:;
            }
            break;
            /* pre_expr: COMP primary_expr */
            case 51: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_PRE_EXPR;
              stack->continue_at_ = 51;
              {
                { (stack->stack_[1].v_.uv26_) = new PreExprNode((stack->sym_data_[1].v_.uv23_), PreExprNode::Ops::Comp); }
              }
              C51:;
            }
            break;
            /* multiplicative_expr: pre_expr */
            case 52: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_MULTIPLICATIVE_EXPR;
              stack->continue_at_ = 52;
              {
                { (stack->stack_[1].v_.uv27_) = (stack->sym_data_[0].v_.uv26_); }
              }
              C52:;
            }
            break;
            /* multiplicative_expr: multiplicative_expr ASTERISK pre_expr */
            case 53: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_MULTIPLICATIVE_EXPR;
              stack->continue_at_ = 53;
              {
                { (stack->stack_[1].v_.uv27_) = new BinaryExprNode((stack->sym_data_[0].v_.uv27_), (stack->sym_data_[1].v_.uv2_), BinaryExprNode::Ops::Mul); }
              }
              C53:;
            }
            break;
            /* multiplicative_expr: multiplicative_expr SLASH pre_expr */
            case 54: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_MULTIPLICATIVE_EXPR;
              stack->continue_at_ = 54;
              {
                { (stack->stack_[1].v_.uv27_) = new BinaryExprNode((stack->sym_data_[0].v_.uv27_), (stack->sym_data_[1].v_.uv2_), BinaryExprNode::Ops::Div); }
              }
              C54:;
            }
            break;
            /* multiplicative_expr: multiplicative_expr PERCENT pre_expr */
            case 55: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_MULTIPLICATIVE_EXPR;
              stack->continue_at_ = 55;
              {
                { (stack->stack_[1].v_.uv27_) = new BinaryExprNode((stack->sym_data_[0].v_.uv27_), (stack->sym_data_[1].v_.uv2_), BinaryExprNode::Ops::Mod); }
              }
              C55:;
            }
            break;
            /* additive_expr: multiplicative_expr */
            case 56: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_ADDITIVE_EXPR;
              stack->continue_at_ = 56;
              {
                { (stack->stack_[1].v_.uv28_) = (stack->sym_data_[0].v_.uv27_); }
              }
              C56:;
            }
            break;
            /* additive_expr: additive_expr PLUS multiplicative_expr */
            case 57: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_ADDITIVE_EXPR;
              stack->continue_at_ = 57;
              {
                { (stack->stack_[1].v_.uv28_) = new BinaryExprNode((stack->sym_data_[0].v_.uv28_), (stack->sym_data_[1].v_.uv2_), BinaryExprNode::Ops::Add); }
              }
              C57:;
            }
            break;
            /* additive_expr: additive_expr MINUS multiplicative_expr */
            case 58: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_ADDITIVE_EXPR;
              stack->continue_at_ = 58;
              {
                { (stack->stack_[1].v_.uv28_) = new BinaryExprNode((stack->sym_data_[0].v_.uv28_), (stack->sym_data_[1].v_.uv2_), BinaryExprNode::Ops::Sub); }
              }
              C58:;
            }
            break;
            /* shift_expr: additive_expr */
            case 59: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_SHIFT_EXPR;
              stack->continue_at_ = 59;
              {
                { (stack->stack_[1].v_.uv29_) = (stack->sym_data_[0].v_.uv28_); }
              }
              C59:;
            }
            break;
            /* shift_expr: shift_expr SHL additive_expr */
            case 60: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_SHIFT_EXPR;
              stack->continue_at_ = 60;
              {
                { (stack->stack_[1].v_.uv29_) = new BinaryExprNode((stack->sym_data_[0].v_.uv29_), (stack->sym_data_[1].v_.uv2_), BinaryExprNode::Ops::LShift); }
              }
              C60:;
            }
            break;
            /* shift_expr: shift_expr SHR additive_expr */
            case 61: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_SHIFT_EXPR;
              stack->continue_at_ = 61;
              {
                { (stack->stack_[1].v_.uv29_) = new BinaryExprNode((stack->sym_data_[0].v_.uv29_), (stack->sym_data_[1].v_.uv2_), BinaryExprNode::Ops::RShift); }
              }
              C61:;
            }
            break;
            /* relative_expr: shift_expr */
            case 62: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_RELATIVE_EXPR;
              stack->continue_at_ = 62;
              {
                { (stack->stack_[1].v_.uv30_) = (stack->sym_data_[0].v_.uv29_); }
              }
              C62:;
            }
            break;
            /* relative_expr: relative_expr LESSER shift_expr */
            case 63: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_RELATIVE_EXPR;
              stack->continue_at_ = 63;
              {
                { (stack->stack_[1].v_.uv30_) = new BinaryExprNode((stack->sym_data_[0].v_.uv30_), (stack->sym_data_[1].v_.uv2_), BinaryExprNode::Ops::Less); }
              }
              C63:;
            }
            break;
            /* relative_expr: relative_expr LESSEQ shift_expr */
            case 64: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_RELATIVE_EXPR;
              stack->continue_at_ = 64;
              {
                { (stack->stack_[1].v_.uv30_) = new BinaryExprNode((stack->sym_data_[0].v_.uv30_), (stack->sym_data_[1].v_.uv2_), BinaryExprNode::Ops::LessEq); }
              }
              C64:;
            }
            break;
            /* relative_expr: relative_expr GREATER shift_expr */
            case 65: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_RELATIVE_EXPR;
              stack->continue_at_ = 65;
              {
                { (stack->stack_[1].v_.uv30_) = new BinaryExprNode((stack->sym_data_[0].v_.uv30_), (stack->sym_data_[1].v_.uv2_), BinaryExprNode::Ops::More); }
              }
              C65:;
            }
            break;
            /* relative_expr: relative_expr GREATEQ shift_expr */
            case 66: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_RELATIVE_EXPR;
              stack->continue_at_ = 66;
              {
                { (stack->stack_[1].v_.uv30_) = new BinaryExprNode((stack->sym_data_[0].v_.uv30_), (stack->sym_data_[1].v_.uv2_), BinaryExprNode::Ops::MoreEq); }
              }
              C66:;
            }
            break;
            /* absolute_expr: relative_expr */
            case 67: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_ABSOLUTE_EXPR;
              stack->continue_at_ = 67;
              {
                { (stack->stack_[1].v_.uv31_) = (stack->sym_data_[0].v_.uv30_); }
              }
              C67:;
            }
            break;
            /* absolute_expr: absolute_expr EQUAL relative_expr */
            case 68: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_ABSOLUTE_EXPR;
              stack->continue_at_ = 68;
              {
                { (stack->stack_[1].v_.uv31_) = new BinaryExprNode((stack->sym_data_[0].v_.uv31_), (stack->sym_data_[1].v_.uv2_), BinaryExprNode::Ops::EQ); }
              }
              C68:;
            }
            break;
            /* absolute_expr: absolute_expr NEQUAL relative_expr */
            case 69: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_ABSOLUTE_EXPR;
              stack->continue_at_ = 69;
              {
                { (stack->stack_[1].v_.uv31_) = new BinaryExprNode((stack->sym_data_[0].v_.uv31_), (stack->sym_data_[1].v_.uv2_), BinaryExprNode::Ops::NEQ); }
              }
              C69:;
            }
            break;
            /* bit_and_expr: absolute_expr */
            case 70: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_BIT_AND_EXPR;
              stack->continue_at_ = 70;
              {
                { (stack->stack_[1].v_.uv32_) = (stack->sym_data_[0].v_.uv31_); }
              }
              C70:;
            }
            break;
            /* bit_and_expr: bit_and_expr AND absolute_expr */
            case 71: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_BIT_AND_EXPR;
              stack->continue_at_ = 71;
              {
                { (stack->stack_[1].v_.uv32_) = new BinaryExprNode((stack->sym_data_[0].v_.uv32_), (stack->sym_data_[1].v_.uv2_), BinaryExprNode::Ops::AND); }
              }
              C71:;
            }
            break;
            /* bit_xor_expr: bit_and_expr */
            case 72: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_BIT_XOR_EXPR;
              stack->continue_at_ = 72;
              {
                { (stack->stack_[1].v_.uv33_) = (stack->sym_data_[0].v_.uv32_); }
              }
              C72:;
            }
            break;
            /* bit_xor_expr: bit_xor_expr XOR bit_and_expr */
            case 73: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_BIT_XOR_EXPR;
              stack->continue_at_ = 73;
              {
                { (stack->stack_[1].v_.uv33_) = new BinaryExprNode((stack->sym_data_[0].v_.uv33_), (stack->sym_data_[1].v_.uv2_), BinaryExprNode::Ops::XOR); }
              }
              C73:;
            }
            break;
            /* bit_or_expr: bit_xor_expr */
            case 74: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_BIT_OR_EXPR;
              stack->continue_at_ = 74;
              {
                { (stack->stack_[1].v_.uv34_) = (stack->sym_data_[0].v_.uv33_); }
              }
              C74:;
            }
            break;
            /* bit_or_expr: bit_or_expr OR bit_xor_expr */
            case 75: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_BIT_OR_EXPR;
              stack->continue_at_ = 75;
              {
                { (stack->stack_[1].v_.uv34_) = new BinaryExprNode((stack->sym_data_[0].v_.uv34_), (stack->sym_data_[1].v_.uv2_), BinaryExprNode::Ops::OR); }
              }
              C75:;
            }
            break;
            /* logic_and_expr: bit_or_expr */
            case 76: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_LOGIC_AND_EXPR;
              stack->continue_at_ = 76;
              {
                { (stack->stack_[1].v_.uv35_) = (stack->sym_data_[0].v_.uv34_); }
              }
              C76:;
            }
            break;
            /* logic_and_expr: logic_and_expr LAND bit_or_expr */
            case 77: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_LOGIC_AND_EXPR;
              stack->continue_at_ = 77;
              {
                { (stack->stack_[1].v_.uv35_) = new BinaryExprNode((stack->sym_data_[0].v_.uv35_), (stack->sym_data_[1].v_.uv2_), BinaryExprNode::Ops::LAND); }
              }
              C77:;
            }
            break;
            /* logic_or_expr: logic_and_expr */
            case 78: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_LOGIC_OR_EXPR;
              stack->continue_at_ = 78;
              {
                { (stack->stack_[1].v_.uv36_) = (stack->sym_data_[0].v_.uv35_); }
              }
              C78:;
            }
            break;
            /* logic_or_expr: logic_or_expr LOR logic_and_expr */
            case 79: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_LOGIC_OR_EXPR;
              stack->continue_at_ = 79;
              {
                { (stack->stack_[1].v_.uv36_) = new BinaryExprNode((stack->sym_data_[0].v_.uv36_), (stack->sym_data_[1].v_.uv2_), BinaryExprNode::Ops::LOR); }
              }
              C79:;
            }
            break;
            /* literal: ID */
            case 80: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_LITERAL;
              stack->continue_at_ = 80;
              {
                { (stack->stack_[1].v_.uv37_) = new IDNode(std::move((stack->sym_data_[0].v_.uv1_))); }
              }
              C80:;
            }
            break;
            /* literal: DECIMAL */
            case 81: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_LITERAL;
              stack->continue_at_ = 81;
              {
                { (stack->stack_[1].v_.uv37_) = new DecimalNode((stack->sym_data_[0].v_.uv0_)); }
              }
              C81:;
            }
            break;
            /* literal: boolean */
            case 82: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_LITERAL;
              stack->continue_at_ = 82;
              {
                { (stack->stack_[1].v_.uv37_) = new BoolNode((stack->sym_data_[0].v_.uv38_)); }
              }
              C82:;
            }
            break;
            /* literal: STRING */
            case 83: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_LITERAL;
              stack->continue_at_ = 83;
              {
                { (stack->stack_[1].v_.uv37_) = StrNode::build(std::move((stack->sym_data_[0].v_.uv1_))); }
              }
              C83:;
            }
            break;
            /* boolean: TRUE */
            case 84: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_BOOLEAN;
              stack->continue_at_ = 84;
              {
                { (stack->stack_[1].v_.uv38_) = true; }
              }
              C84:;
            }
            break;
            /* boolean: FALSE */
            case 85: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = CARB_BOOLEAN;
              stack->continue_at_ = 85;
              {
                { (stack->stack_[1].v_.uv38_) = false; }
              }
              C85:;
            }
            break;
          } /* switch */
        } /* scope guard */
        
        stack->pos_ -= stack->current_production_length_;
        stack->top_of_stack_has_sym_data_ = stack->top_of_stack_has_common_data_ = 1;
        action = carb_parse_table[carb_num_columns * stack->stack_[stack->pos_ - 1].state_ + (stack->current_production_nonterminal_ - carb_minimum_sym)];
        if (action <= 0) {
          stack->continue_at_ = 0;
          /* Internal error */
          return _CARB_INTERNAL_ERROR;
        }
        if (stack->num_stack_allocated_ == stack->pos_) {
          size_t new_num_allocated;
          if (stack->num_stack_allocated_) {
            new_num_allocated = stack->num_stack_allocated_ * 2;
            if (new_num_allocated <= stack->num_stack_allocated_) {
              /* Overflow in allocation */
              return _CARB_OVERFLOW;
            }
          }
          else {
            new_num_allocated = 16;
          }
          
          if (new_num_allocated > (SIZE_MAX / sizeof(struct carb_sym_data))) {
            /* Overflow in allocation */
            return _CARB_OVERFLOW;
          }
          
          void *p = realloc(stack->stack_, new_num_allocated * sizeof(struct carb_sym_data));
          if (!p) {
            /* Out of memory */
            return _CARB_NO_MEMORY;
          }
          stack->num_stack_allocated_ = stack->new_buf_num_allocated_;
        }
        stack->stack_[stack->pos_++].state_ = action /* action for a "goto" shift is the ordinal */;
        stack->top_of_stack_has_sym_data_ = 0;
        stack->top_of_stack_has_common_data_ = 0;
        struct carb_sym_data *sd = stack->stack_ + stack->pos_ - 1;
        memcpy(sd, stack->stack_+1, sizeof(*sd));
        sd->state_ = action;
        stack->slot_1_has_common_data_ = 0;
        stack->slot_1_has_sym_data_ = 0;
        stack->top_of_stack_has_common_data_ = 1;
        stack->top_of_stack_has_sym_data_ = 1;
      } /* action < 0 */
      else /* action == 0 */ {
        /* check if we can recover using an error token. */
        size_t n;
        for (n = 0; n < stack->pos_; ++n) {
          int err_action;
          err_action = carb_parse_table[carb_num_columns * stack->stack_[n].state_ + (44 /* error token */ - carb_minimum_sym)];
          if (err_action > 0) {
            /* we can transition on the error token somewhere on the stack */
            break;
          }
        }
        /* Enter error-token recovery mode given that such a recovery is possible */
        stack->error_recovery_ = (n != stack->pos_);
        /* Issue the error here */
        if (!stack->mute_error_turns_) {
          stack->mute_error_turns_ = 3;
          stack->continue_at_ = 0;
          /* Syntax error */
          return _CARB_SYNTAX_ERROR;
        }
        else {
          stack->mute_error_turns_--;
          if (sym == CARB_INPUT_END) {
            /* EOF means we cannot shift to recover, and errors are muted, so return completion */
            stack->pending_reset_ = 1;
            return _CARB_FINISH;
          }
          /* Retain EOF but discard any other sym so we make progress */
          stack->continue_at_ = 0;
          /* Next token */
          return _CARB_FEED_ME;
        }
      }
    } /* !stack->error_recovery_ */
    if (stack->error_recovery_) {
      size_t n;
      n = stack->pos_;
      if (n) {
        do {
          --n;
          /* Can we shift an error token? */
          int err_action;
          err_action = carb_parse_table[carb_num_columns * stack->stack_[n].state_ + (44 /* error token */ - carb_minimum_sym)];
          if (err_action > 0) {
            /* Does the resulting state accept the current symbol? */
            int err_sym_action;
            err_sym_action = carb_parse_table[carb_num_columns * err_action + (sym - carb_minimum_sym)];
            if (err_sym_action) {
              /* Current symbol is accepted, recover error condition by shifting the error token and then process the symbol as usual */
              stack->pos_ = n + 1;
              stack->top_of_stack_has_sym_data_ = stack->top_of_stack_has_common_data_ = 1;
              /* Push the state of the error transition */
              if (stack->num_stack_allocated_ == stack->pos_) {
                size_t new_num_allocated;
                if (stack->num_stack_allocated_) {
                  new_num_allocated = stack->num_stack_allocated_ * 2;
                  if (new_num_allocated <= stack->num_stack_allocated_) {
                    /* Overflow in allocation */
                    return _CARB_OVERFLOW;
                  }
                }
                else {
                  new_num_allocated = 16;
                }
                
                if (new_num_allocated > (SIZE_MAX / sizeof(struct carb_sym_data))) {
                  /* Overflow in allocation */
                  return _CARB_OVERFLOW;
                }
                
                void *p = realloc(stack->stack_, new_num_allocated * sizeof(struct carb_sym_data));
                if (!p) {
                  /* Out of memory */
                  return _CARB_NO_MEMORY;
                }
                stack->num_stack_allocated_ = stack->new_buf_num_allocated_;
              }
              stack->stack_[stack->pos_++].state_ = err_action;
              stack->top_of_stack_has_sym_data_ = 0;
              stack->top_of_stack_has_common_data_ = 0;
              stack->error_recovery_ = 0;
              /* Break out of do { .. } while loop, we've recovered */
              break;
            } /* if (err_sym_action) (if the current sym can continue after an error transition) */
          } /* if (err_action) (if the state at position 'n' can accept an error transition) */
        } while (n);
      }
      if (stack->error_recovery_) {
        /* Did not yet recover, discard current sym and get next */
        if (sym == CARB_INPUT_END) {
          /* EOF means we cannot shift to recover, so return completion */
          stack->pending_reset_ = 1;
          return _CARB_FINISH;
        }
        stack->continue_at_ = 0;
        /* Next token */
        return _CARB_FEED_ME;
      }
    } /* stack->error_recovery_ */
  } /* for (;;) */
}
/* --------- END OF GENERATED CODE ------------ */
